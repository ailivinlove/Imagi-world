<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imagi-world</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            margin: 20px 0;
            font-size: 2rem;
            text-align: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .controls {
            background: #16213e;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #numTrialsSlider {
            width: 100%;
            margin-top: 8px;
        }

        #numTrialsDisplay {
            display: block;
            margin-top: 8px;
            font-weight: 600;
            color: #e94560;
        }

        .label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        .hint {
            display: block;
            margin-top: 4px;
            color: #aaa;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        input[type="range"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: #0f3460;
            color: #eee;
            border: 1px solid #1a4d7a;
            border-radius: 6px;
            font-size: 1rem;
            margin-left: 10px;
        }

        input[type="number"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .range-value {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #e94560;
        }

        .dual-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .dual-control input[type="range"] {
            flex: 1;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #d63651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: #0f3460;
        }

        button.secondary:hover:not(:disabled) {
            background: #1a4d7a;
        }

        button.danger {
            background: #c0392b;
        }

        button.danger:hover:not(:disabled) {
            background: #a93226;
        }

        button.success {
            background: #27ae60;
        }

        button.success:hover:not(:disabled) {
            background: #229954;
        }

        .game-area {
            background: #16213e;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .status {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            width: 100%;
        }

        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #e94560;
        }

        .response-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .response-buttons button {
            flex: 1;
            padding: 20px;
            font-size: 1.2rem;
        }

        .match-btn {
            background: #2ecc71;
        }

        .match-btn:hover:not(:disabled) {
            background: #27ae60;
        }

        .no-match-btn {
            background: #e74c3c;
        }

        .no-match-btn:hover:not(:disabled) {
            background: #c0392b;
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .feedback.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .feedback.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        #debug {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
        }

        #debug h3 {
            margin-bottom: 15px;
            color: #e94560;
        }

        .debug-premise {
            margin-bottom: 10px;
            padding: 8px;
            background: #16213e;
            border-radius: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .voice-info {
            background: #0f3460;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 10px;
        }

        .voice-info strong {
            color: #e94560;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .test-panel {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .test-result {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .test-result.pass {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .test-result.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .premise-display {
            font-size: 1.3rem;
            color: #aaa;
            margin: 20px 0;
            min-height: 60px;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .response-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒ€Imagi-worldðŸŒ€</h1>

        <div class="controls">
            <div class="control-group">
                <label>N-Back Level: <span class="range-value" id="n-value">1</span></label>
                <input type="range" id="n-slider" min="1" max="5" value="1">
            </div>

            <div class="control-group">
                <label>Atoms per Premise (k): <span class="range-value" id="k-value">1</span></label>
                <input type="range" id="k-slider" min="1" max="4" value="1">
            </div>

            <div class="control-group">
                <label>Seconds per Trial: <span class="range-value" id="spt-value">6.0</span> s</label>
                <div class="dual-control">
                    <input type="range" id="spt-slider" min="2" max="20" step="0.5" value="6.0">
                    <input type="number" id="spt-number" min="2" max="20" step="0.5" value="6.0">
                </div>
            </div>

            <div class="control-group">
                <label for="numTrialsInput">Number of trials per session</label>
                <input id="numTrialsInput" type="number" min="1" max="10000" step="1" value="20" />
                <input id="numTrialsSlider" type="range" min="1" max="500" step="1" value="20" />
                <span id="numTrialsDisplay">Trials: 20</span>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="transitivity-toggle">
                <label for="transitivity-toggle" style="margin-bottom: 0;">Enable Advanced Transitivity</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="lock-seed-toggle">
                <label for="lock-seed-toggle" style="margin-bottom: 0;">Lock seed (reuse until unlocked)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="reset-seed-toggle">
                <label for="reset-seed-toggle" style="margin-bottom: 0;">Reset stats & logs on Restart</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="debug-toggle">
                <label for="debug-toggle" style="margin-bottom: 0;">Show Debug Panel</label>
            </div>

            <div style="margin-top: 20px;">
                <div class="button-group">
                    <button id="start-btn" class="success">Start</button>
                    <button id="restart-btn" class="success" disabled>Restart</button>
                    <button id="stop-btn" class="danger" disabled>Stop</button>
                    <button id="repeat-btn" class="secondary" disabled>Repeat Audio</button>
                    <button id="preview-btn" class="secondary">Voice Preview</button>
                </div>
                <div class="button-group">
                    <button id="test-btn" class="secondary">Run Tests</button>
                    <button id="export-btn" class="secondary">Download so far</button>
                </div>
            </div>

            <div class="voice-info" id="voice-info">Initializing voice...</div>
        </div>

        <div class="game-area">
            <div class="status" id="status">Preparing voice system...</div>
            <div class="premise-display" id="premise-display"></div>

            <div class="response-buttons">
                <button class="match-btn" id="match-btn" disabled>
                    MATCH<br><small>(Spacebar)</small>
                </button>
                <button class="no-match-btn" id="no-match-btn" disabled>
                    NO MATCH<br><small>(Enter)</small>
                </button>
            </div>

            <div class="feedback" id="feedback"></div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Trial</div>
                    <div class="stat-value" id="trial-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="accuracy">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Rolling Acc.</div>
                    <div class="stat-value" id="rolling-acc">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Omissions</div>
                    <div class="stat-value" id="omissions">0</div>
                </div>
            </div>
        </div>

        <div id="debug" hidden>
            <h3>Debug Panel - Last Premises</h3>
            <div id="debug-content"></div>
        </div>

        <div id="test-panel" class="test-panel" hidden>
            <h3>Test Results</h3>
            <div id="test-results"></div>
        </div>
    </div>

    <script type="module">
        const RELATION_WORDS = { N: 'north of', S: 'south of', E: 'east of', W: 'west of' };
        const MATCH_AXES = ['N', 'S', 'E', 'W'];
        const ACCEPTANCE_ALPHA = 0.25;
        const ACCEPTANCE_BETA = 0.5;
        const FIRST_N_NOVELTY = 6;
        const HAMMING_WINDOW = 8;
        const NOVELTY_OVERRIDE_THRESHOLD = 30;
        const MAX_GENERATION_ATTEMPTS = 240;
        const conflictConfig = {
            foilRate: 0.35,
            foilTypesWeights: {
                ANCHOR_ONE: 0.20,
                PAIR_SWAP: 0.20,
                PARITY_OFF: 0.15,
                AXIS_ORTHO: 0.15,
                DERIVED_IN_ONE: 0.15,
                WINDOW_SHADOW: 0.15
            }
        };

        const NUM_TRIALS_KEY = 'numTrials';
        const numTrialsInput = document.getElementById('numTrialsInput');
        const numTrialsSlider = document.getElementById('numTrialsSlider');
        const numTrialsDisplay = document.getElementById('numTrialsDisplay');

        function loadNumTrials() {
            const v = parseInt(localStorage.getItem(NUM_TRIALS_KEY) || '20', 10);
            const clamped = Math.min(10000, Math.max(1, isNaN(v) ? 20 : v));
            numTrialsInput.value = String(clamped);
            numTrialsSlider.value = String(Math.min(500, clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            return clamped;
        }

        function persistNumTrials(v) {
            const clamped = Math.min(10000, Math.max(1, v | 0));
            localStorage.setItem(NUM_TRIALS_KEY, String(clamped));
            numTrialsDisplay.textContent = `Trials: ${clamped}`;
            if (clamped <= 500) numTrialsSlider.value = String(clamped);
            numTrialsInput.value = String(clamped);
            return clamped;
        }

        numTrialsInput.addEventListener('change', () => {
            const value = parseInt(numTrialsInput.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        numTrialsSlider.addEventListener('input', () => {
            const value = parseInt(numTrialsSlider.value, 10);
            persistNumTrials(isNaN(value) ? 20 : value);
        });

        const initialNumTrials = loadNumTrials();

        function sessionDefaults() {
            return {
                state: "STOPPED",
                trialIndex: 0,
                numTrials: initialNumTrials,
                seedSession: null,
                n: parseInt(document.getElementById('n-slider').value, 10),
                k: parseInt(document.getElementById('k-slider').value, 10),
                secondsPerTrial: parseFloat(document.getElementById('spt-slider').value)
            };
        }


        function cryptoRandom32() {
            if (window.crypto && window.crypto.getRandomValues) {
                const arr = new Uint32Array(1);
                window.crypto.getRandomValues(arr);
                return arr[0] >>> 0;
            }

            let x = Date.now() ^ Math.floor(Math.random() * 0xffffffff);
            x ^= x << 13;
            x ^= x >>> 17;
            x ^= x << 5;
            return x >>> 0;
        }

        function fnv1aHash(parts) {
            let hash = 0x811c9dc5;
            for (const part of parts) {
                const value = (part >>> 0);
                hash ^= value;
                hash = Math.imul(hash, 0x01000193);
            }
            return hash >>> 0;
        }

        class Mulberry32 {
            constructor(seed) {
                this.state = seed >>> 0;
            }

            next() {
                let t = this.state += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }

            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }

            shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            weightedChoice(items, weights) {
                const cumulative = [];
                let total = 0;
                for (const weight of weights) {
                    total += weight;
                    cumulative.push(total);
                }
                const r = this.next() * total;
                for (let i = 0; i < cumulative.length; i++) {
                    if (r <= cumulative[i]) return items[i];
                }
                return items[items.length - 1];
            }

            nextBetween(min, max) {
                return min + (max - min) * this.next();
            }
        }

        class SeedManager {
            constructor() {
                this.runCounterKey = 'relational-nback-run-counter';
                this.seedKey = 'relational-nback-last-seed';
                this.lockKey = 'relational-nback-lock-seed';
                this.sessionSeed = null;
                this.runCounter = this.loadRunCounter();
            }

            loadRunCounter() {
                const raw = localStorage.getItem(this.runCounterKey);
                const parsed = raw ? parseInt(raw, 10) : 0;
                return Number.isFinite(parsed) ? parsed : 0;
            }

            getLockPreference() {
                return localStorage.getItem(this.lockKey) === 'true';
            }

            setLockPreference(lock) {
                localStorage.setItem(this.lockKey, lock ? 'true' : 'false');
            }

            incrementRunCounter() {
                this.runCounter += 1;
                localStorage.setItem(this.runCounterKey, String(this.runCounter));
                return this.runCounter;
            }

            generateSessionSeed(lockSeed) {
                if (lockSeed) {
                    const existing = localStorage.getItem(this.seedKey);
                    if (existing) {
                        this.sessionSeed = parseInt(existing, 10) >>> 0;
                        return this.sessionSeed;
                    }
                }

                const counter = this.incrementRunCounter();
                const random = cryptoRandom32();
                const salt = Date.now() >>> 0;
                const seed = fnv1aHash([counter, random, salt]);
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
                return seed;
            }

            persistSessionSeed(seed) {
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
            }
        }

        class DisjointSet {
            constructor(elements = []) {
                this.parent = new Map();
                this.rank = new Map();
                elements.forEach(e => this.makeSet(e));
            }

            makeSet(x) {
                if (!this.parent.has(x)) {
                    this.parent.set(x, x);
                    this.rank.set(x, 0);
                }
            }

            find(x) {
                if (!this.parent.has(x)) {
                    this.makeSet(x);
                }
                const parent = this.parent.get(x);
                if (parent !== x) {
                    const root = this.find(parent);
                    this.parent.set(x, root);
                    return root;
                }
                return x;
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                if (rootX === rootY) return rootX;

                const rankX = this.rank.get(rootX) || 0;
                const rankY = this.rank.get(rootY) || 0;

                if (rankX < rankY) {
                    this.parent.set(rootX, rootY);
                    return rootY;
                } else if (rankX > rankY) {
                    this.parent.set(rootY, rootX);
                    return rootX;
                } else {
                    this.parent.set(rootY, rootX);
                    this.rank.set(rootX, rankX + 1);
                    return rootX;
                }
            }

            getSets() {
                const result = new Map();
                for (const key of this.parent.keys()) {
                    const root = this.find(key);
                    if (!result.has(root)) {
                        result.set(root, new Set());
                    }
                    result.get(root).add(key);
                }
                return result;
            }
        }

        class Atom {
            constructor(axis, head, tail) {
                this.axis = axis;
                this.head = head;
                this.tail = tail;
            }

            equals(other) {
                return this.axis === other.axis && this.head === other.head && this.tail === other.tail;
            }

            toString() {
                return `${this.head} is ${RELATION_WORDS[this.axis]} ${this.tail}`;
            }

            toKey() {
                return `${this.axis},${this.head},${this.tail}`;
            }

            static invert(atom) {
                const invMap = { N: 'S', S: 'N', E: 'W', W: 'E' };
                return new Atom(invMap[atom.axis], atom.tail, atom.head);
            }
        }

        class Premise {
            constructor(atoms) {
                this.atoms = [...atoms].sort((a, b) => {
                    if (a.axis !== b.axis) return a.axis.localeCompare(b.axis);
                    if (a.head !== b.head) return a.head.localeCompare(b.head);
                    return a.tail.localeCompare(b.tail);
                });
                this.features = this.computeFeatures();
            }

            getLetters() {
                const letters = new Set();
                this.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                return letters;
            }

            computeFeatures() {
                const lettersSet = new Set();
                const degreeVector = new Map();
                const axisProfile = new Map();
                const indexMap = {
                    N: [0, 1],
                    S: [2, 3],
                    E: [4, 5],
                    W: [6, 7]
                };

                const ensureVector = (letter) => {
                    if (!degreeVector.has(letter)) {
                        degreeVector.set(letter, [0, 0, 0, 0, 0, 0, 0, 0]);
                    }
                    return degreeVector.get(letter);
                };

                this.atoms.forEach(atom => {
                    lettersSet.add(atom.head);
                    lettersSet.add(atom.tail);

                    const [outIdx, inIdx] = indexMap[atom.axis];
                    const headVec = ensureVector(atom.head);
                    headVec[outIdx] += 1;
                    const tailVec = ensureVector(atom.tail);
                    tailVec[inIdx] += 1;

                    axisProfile.set(atom.axis, (axisProfile.get(atom.axis) || 0) + 1);
                });

                return {
                    lettersSet,
                    degreeVector,
                    skeletonIsoSignature: this.isoSignature(),
                    atomAxisProfile: axisProfile
                };
            }

            getFeatures() {
                return this.features;
            }

            atomKeys() {
                return this.atoms.map(atom => atom.toKey());
            }

            toKey() {
                return this.atomKeys().join('|');
            }

            toString() {
                return this.atoms.map(a => a.toString()).join('; ');
            }

            toNaturalSpeech() {
                return this.atoms.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ') + '.';
            }

            mirrorKey() {
                const canonicalAtoms = this.atoms.map(atom => {
                    const inverted = Atom.invert(atom);
                    const current = `${atom.axis}|${atom.head}|${atom.tail}`;
                    const flipped = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return current < flipped ? current : flipped;
                }).sort();
                return canonicalAtoms.join('|');
            }

            isoSignature() {
                const letterMap = new Map();
                let nextCharCode = 'a'.charCodeAt(0);
                const normalized = this.atoms.map(atom => {
                    if (!letterMap.has(atom.head)) {
                        letterMap.set(atom.head, String.fromCharCode(nextCharCode++));
                    }
                    if (!letterMap.has(atom.tail)) {
                        letterMap.set(atom.tail, String.fromCharCode(nextCharCode++));
                    }
                    const headNorm = letterMap.get(atom.head);
                    const tailNorm = letterMap.get(atom.tail);
                    const normalizedAtom = new Atom(atom.axis, headNorm, tailNorm);
                    const inverted = Atom.invert(normalizedAtom);
                    const keyCurrent = `${normalizedAtom.axis}|${normalizedAtom.head}|${normalizedAtom.tail}`;
                    const keyInv = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return keyCurrent < keyInv ? keyCurrent : keyInv;
                });
                return normalized.sort().join('|');
            }
        }

        class NoveltyManager {
            constructor(windowSize = HAMMING_WINDOW, firstN = FIRST_N_NOVELTY) {
                this.windowSize = windowSize;
                this.firstN = firstN;
                this.seenExact = new Set();
                this.seenMirror = new Set();
                this.seenIso = new Set();
                this.history = [];
            }

            buildSignatures(premise) {
                return {
                    exact: premise.toKey(),
                    mirror: premise.mirrorKey(),
                    iso: premise.isoSignature(),
                    atoms: premise.atomKeys()
                };
            }

            computeHamming(atoms) {
                if (this.history.length === 0) return this.windowSize;
                const freq1 = this.buildFrequencyMap(atoms);
                let total = 0;
                const limit = Math.min(this.windowSize, this.history.length);
                for (let i = 0; i < limit; i++) {
                    const other = this.history[this.history.length - 1 - i];
                    const freq2 = other.frequency;
                    const allKeys = new Set([...freq1.keys(), ...freq2.keys()]);
                    let diff = 0;
                    allKeys.forEach(key => {
                        diff += Math.abs((freq1.get(key) || 0) - (freq2.get(key) || 0));
                    });
                    total += diff;
                }
                return total / limit;
            }

            buildFrequencyMap(atoms) {
                const freq = new Map();
                atoms.forEach(key => {
                    freq.set(key, (freq.get(key) || 0) + 1);
                });
                return freq;
            }

            evaluate(premise, signatures, trialIndex) {
                const exactHit = this.seenExact.has(signatures.exact);
                if (exactHit) {
                    return {
                        blocked: true,
                        reason: 'exact-repeat',
                        penalty: Infinity,
                        noveltyScores: { exact: 1, mirror: 0, iso: 0, hamming: 0 }
                    };
                }

                const mirrorHit = this.seenMirror.has(signatures.mirror);
                const isoHit = this.seenIso.has(signatures.iso);
                const hamming = this.computeHamming(signatures.atoms);

                const noveltyScores = {
                    exact: mirrorHit ? 1 : 0,
                    mirror: mirrorHit ? 1 : 0,
                    iso: isoHit ? 1 : 0,
                    hamming
                };

                if (trialIndex < this.firstN && (mirrorHit || isoHit)) {
                    return {
                        blocked: true,
                        reason: 'novelty-mode',
                        penalty: Infinity,
                        noveltyScores
                    };
                }

                let penalty = 0;
                if (mirrorHit) penalty += 1;
                if (isoHit) penalty += 2;

                return {
                    blocked: false,
                    penalty,
                    noveltyScores
                };
            }

            register(signatures) {
                this.seenExact.add(signatures.exact);
                this.seenMirror.add(signatures.mirror);
                this.seenIso.add(signatures.iso);
                this.history.push({
                    signature: signatures.exact,
                    frequency: this.buildFrequencyMap(signatures.atoms)
                });
                if (this.history.length > this.windowSize) {
                    this.history.shift();
                }
            }

            reset() {
                this.seenExact.clear();
                this.seenMirror.clear();
                this.seenIso.clear();
                this.history = [];
            }
        }

        class LetterPoolManager {
            constructor(allLetters, rng, usageTracker) {
                this.allLetters = allLetters;
                this.rng = rng;
                this.usageTracker = usageTracker;
                this.currentPool = [];
            }

            getUsage(letter) {
                const usage = this.usageTracker.get(letter);
                if (!usage) return 0;
                return usage.head + usage.tail;
            }

            sampleLetters(count, candidates = this.allLetters) {
                const available = candidates.filter(l => !this.currentPool.includes(l));
                const selection = [];
                const pool = [...available];
                while (selection.length < count && pool.length > 0) {
                    const weights = pool.map(letter => 1 / (1 + this.getUsage(letter)));
                    const choice = this.rng.weightedChoice(pool, weights);
                    selection.push(choice);
                    const index = pool.indexOf(choice);
                    pool.splice(index, 1);
                }
                return selection;
            }

            nextPool(k, options = {}) {
                const { expand = false } = options;
                const min = k + 1;
                const max = Math.min(6, 2 * k + 2);
                const targetSize = Math.max(min, Math.min(max, (this.currentPool.length || min) + (expand ? 1 : 0)));

                if (this.currentPool.length === 0) {
                    const letters = this.rng.shuffle(this.allLetters).slice(0, targetSize);
                    this.currentPool = letters;
                    return this.currentPool;
                }

                const drift = expand ? 0.5 : this.rng.nextBetween(0.3, 0.5);
                const keepCount = Math.max(min, Math.round(targetSize * (1 - drift)));
                const orderedByUsage = [...this.currentPool].sort((a, b) => this.getUsage(a) - this.getUsage(b));
                const keep = orderedByUsage.slice(0, keepCount);
                const needed = targetSize - keep.length;
                const candidates = this.allLetters.filter(letter => !keep.includes(letter));
                const additions = this.sampleLetters(needed, candidates);
                this.currentPool = this.rng.shuffle([...keep, ...additions]);
                return this.currentPool;
            }
        }

        function collectLetters(atoms) {
            const set = new Set();
            atoms.forEach(atom => {
                set.add(atom.head);
                set.add(atom.tail);
            });
            return set;
        }

        function addEdge(map, from, to) {
            if (!map.has(from)) {
                map.set(from, new Set());
            }
            map.get(from).add(to);
        }

        function topologicalAssign(nodes, edges) {
            const indegree = new Map();
            nodes.forEach(node => indegree.set(node, 0));
            edges.forEach((targets, source) => {
                targets.forEach(target => {
                    indegree.set(target, (indegree.get(target) || 0) + 1);
                });
            });

            const queue = [];
            indegree.forEach((degree, node) => {
                if (degree === 0) queue.push(node);
            });

            const order = [];
            while (queue.length > 0) {
                const node = queue.shift();
                order.push(node);
                const neighbors = edges.get(node);
                if (!neighbors) continue;
                neighbors.forEach(neighbor => {
                    indegree.set(neighbor, indegree.get(neighbor) - 1);
                    if (indegree.get(neighbor) === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            if (order.length !== nodes.length) {
                return { cycle: true, values: new Map() };
            }

            const values = new Map();
            order.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
                const base = values.get(node);
                const neighbors = edges.get(node);
                if (!neighbors) return;
                neighbors.forEach(neighbor => {
                    const current = values.get(neighbor) || 0;
                    const candidate = Math.max(current, base + 1);
                    values.set(neighbor, candidate);
                });
            });

            nodes.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
            });

            return { cycle: false, values };
        }

        function buildReachability(nodes, edges) {
            const reach = new Map();
            nodes.forEach(node => {
                const visited = new Set();
                const stack = [node];
                while (stack.length) {
                    const current = stack.pop();
                    const neighbors = edges.get(current);
                    if (!neighbors) continue;
                    neighbors.forEach(next => {
                        if (!visited.has(next)) {
                            visited.add(next);
                            stack.push(next);
                        }
                    });
                }
                reach.set(node, visited);
            });
            return reach;
        }

        class ConstraintSolver {
            analyze(allAtoms) {
                const letters = collectLetters(allAtoms);
                const ufX = new DisjointSet(letters);
                const ufY = new DisjointSet(letters);

                const graphX = new Map();
                const graphY = new Map();

                for (const atom of allAtoms) {
                    if (atom.axis === 'N' || atom.axis === 'S') {
                        ufX.union(atom.head, atom.tail);
                    } else {
                        ufY.union(atom.head, atom.tail);
                    }
                }

                for (const atom of allAtoms) {
                    if (atom.axis === 'N') {
                        const lesser = ufY.find(atom.tail);
                        const greater = ufY.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'S') {
                        const lesser = ufY.find(atom.head);
                        const greater = ufY.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'E') {
                        const lesser = ufX.find(atom.tail);
                        const greater = ufX.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    } else if (atom.axis === 'W') {
                        const lesser = ufX.find(atom.head);
                        const greater = ufX.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    }
                }

                const nodesX = Array.from(new Set([...graphX.keys(), ...Array.from(graphX.values()).flat()]));
                ufX.parent.forEach((_, letter) => nodesX.push(ufX.find(letter)));
                const uniqueNodesX = Array.from(new Set(nodesX));

                const nodesY = Array.from(new Set([...graphY.keys(), ...Array.from(graphY.values()).flat()]));
                ufY.parent.forEach((_, letter) => nodesY.push(ufY.find(letter)));
                const uniqueNodesY = Array.from(new Set(nodesY));

                const assignX = topologicalAssign(uniqueNodesX, graphX);
                if (assignX.cycle) {
                    return { ok: false, reason: 'horizontal-cycle' };
                }

                const assignY = topologicalAssign(uniqueNodesY, graphY);
                if (assignY.cycle) {
                    return { ok: false, reason: 'vertical-cycle' };
                }

                const coordinates = new Map();
                letters.forEach(letter => {
                    const xRep = ufX.find(letter);
                    const yRep = ufY.find(letter);
                    const x = assignX.values.get(xRep) || 0;
                    const y = assignY.values.get(yRep) || 0;
                    coordinates.set(letter, { x, y });
                });

                return {
                    ok: true,
                    coordinates,
                    ufX,
                    ufY,
                    graphX,
                    graphY,
                    nodesX: uniqueNodesX,
                    nodesY: uniqueNodesY
                };
            }

            evaluate(windowAtoms, candidateAtoms) {
                return this.analyze([...windowAtoms, ...candidateAtoms]);
            }
        }

        class EquivalenceEngine {
            constructor(transitivityEnabled = false) {
                this.transitivityEnabled = transitivityEnabled;
            }

            setTransitivity(enabled) {
                this.transitivityEnabled = enabled;
            }

            lettersOf(premise) {
                const letters = new Set();
                premise.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                return letters;
            }

            computeInvertibleMapping(atomsA, atomsB) {
                const mapping = [];
                const used = new Set();

                const search = (index) => {
                    if (index === atomsA.length) return true;
                    for (let j = 0; j < atomsB.length; j++) {
                        if (used.has(j)) continue;
                        if (atomsA[index].equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: false });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                        const inverted = Atom.invert(atomsA[index]);
                        if (inverted.equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: true });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                    }
                    return false;
                };

                const ok = search(0);
                return ok ? mapping.slice() : null;
            }

            analyzeMidWindow(midAtoms) {
                if (!midAtoms || midAtoms.length === 0) {
                    return { ok: false };
                }
                const solver = new ConstraintSolver();
                const analysis = solver.analyze(midAtoms);
                if (!analysis.ok) {
                    return { ok: false };
                }
                const reachX = buildReachability(analysis.nodesX, analysis.graphX);
                const reachY = buildReachability(analysis.nodesY, analysis.graphY);
                return { ok: true, analysis, reachX, reachY };
            }

            isDerivableFromMid(atom, midInfo) {
                if (!midInfo.ok) return false;
                const { analysis, reachX, reachY } = midInfo;
                if (atom.axis === 'N') {
                    const lesser = analysis.ufY.find(atom.tail);
                    const greater = analysis.ufY.find(atom.head);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'S') {
                    const lesser = analysis.ufY.find(atom.head);
                    const greater = analysis.ufY.find(atom.tail);
                    const reach = reachY.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'E') {
                    const lesser = analysis.ufX.find(atom.tail);
                    const greater = analysis.ufX.find(atom.head);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                if (atom.axis === 'W') {
                    const lesser = analysis.ufX.find(atom.head);
                    const greater = analysis.ufX.find(atom.tail);
                    const reach = reachX.get(lesser);
                    return reach ? reach.has(greater) : false;
                }
                return false;
            }

            Equivalent(premA, premB, windowAtoms = [], midAtoms = []) {
                const atomsA = premA.atoms;
                const atomsB = premB.atoms;

                if (atomsA.length !== atomsB.length) {
                    return { ok: false, reason: 'parity' };
                }

                const mapping = this.computeInvertibleMapping(atomsA, atomsB);
                if (!mapping) {
                    return { ok: false, reason: 'mapping' };
                }

                const lettersA = this.lettersOf(premA);
                const lettersB = this.lettersOf(premB);
                const shared = new Set();
                lettersA.forEach(letter => {
                    if (lettersB.has(letter)) {
                        shared.add(letter);
                    }
                });
                if (shared.size < 2) {
                    return { ok: false, reason: 'anchors' };
                }

                const solver = new ConstraintSolver();
                const satResult = solver.analyze([...windowAtoms, ...atomsA, ...atomsB]);
                if (!satResult.ok) {
                    return { ok: false, reason: 'sat' };
                }

                const midInfo = this.analyzeMidWindow(midAtoms);
                if (midInfo.ok) {
                    for (const atom of [...atomsA, ...atomsB]) {
                        if (this.isDerivableFromMid(atom, midInfo) || this.isDerivableFromMid(Atom.invert(atom), midInfo)) {
                            return {
                                ok: false,
                                reason: 'mid-window-derivable',
                                mapping,
                                sharedLetters: Array.from(shared),
                                midWindowDerivable: true
                            };
                        }
                    }
                }

                return {
                    ok: true,
                    type: 'invertible',
                    mapping,
                    sharedLetters: Array.from(shared),
                    midWindowDerivable: false
                };
            }

            computeCertificate(nBackPremise, candidatePremise, midAtoms, windowAtoms = []) {
                if (!nBackPremise) {
                    return { match: false, reason: 'no-nback' };
                }

                if (nBackPremise.toKey() === candidatePremise.toKey()) {
                    return { match: false, reason: 'identity' };
                }

                const result = this.Equivalent(nBackPremise, candidatePremise, windowAtoms, midAtoms || []);
                if (!result.ok) {
                    const response = { match: false, reason: result.reason };
                    if (result.reason === 'mid-window-derivable' || result.midWindowDerivable) {
                        response.midWindowDerivable = true;
                        if (this.transitivityEnabled) {
                            return {
                                match: true,
                                certificate: {
                                    type: 'invertible',
                                    mapping: result.mapping || [],
                                    sharedLetters: result.sharedLetters || [],
                                    parity: true,
                                    midWindowDerivable: true
                                },
                                midWindowDerivable: true
                            };
                        }
                    }
                    return response;
                }

                const certificate = {
                    type: result.type,
                    mapping: result.mapping,
                    sharedLetters: result.sharedLetters,
                    parity: true,
                    midWindowDerivable: false
                };

                return { match: true, certificate, midWindowDerivable: false };
            }
        }

        class MatchPlanner {
            constructor(rng) {
                this.rng = rng;
                this.schedule = [];
                this.flips = new Map();
                this.matchModeBag = [];
                this.decoyModeBag = [];
                this.foilRate = conflictConfig.foilRate;
                this.foilTypes = Object.keys(conflictConfig.foilTypesWeights);
                this.foilWeights = this.foilTypes.map(type => conflictConfig.foilTypesWeights[type]);
            }

            plan(totalTrials, n) {
                this.schedule = new Array(totalTrials).fill(false);
                this.flips.clear();
                const rate = this.rng.nextBetween(0.35, 0.55);
                const history = [];
                for (let i = 0; i < totalTrials; i++) {
                    if (i < n) {
                        this.schedule[i] = false;
                        history.push(false);
                        continue;
                    }

                    let decision = this.rng.next() < rate;
                    if (this.wouldRepeat(history, decision)) {
                        decision = !decision;
                        this.flips.set(i, true);
                    }

                    this.schedule[i] = decision;
                    history.push(decision);
                    if (history.length > 24) history.shift();
                }
                return this.schedule;
            }

            chooseConflictMode(plannedMatch) {
                if (plannedMatch) {
                    if (this.matchModeBag.length === 0) {
                        this.matchModeBag = this.rng.shuffle(['BSM', 'CAC']);
                    }
                    return this.matchModeBag.pop();
                }
                if (this.decoyModeBag.length === 0) {
                    const decoys = ['ASNM', 'APNM', 'PPHF', 'CBB', 'WLC', 'ISD'];
                    const bag = [];
                    for (let i = 0; i < 2; i++) {
                        bag.push(...decoys);
                    }
                    this.decoyModeBag = this.rng.shuffle(bag);
                }
                return this.decoyModeBag.pop();
            }

            sampleFoilType() {
                if (this.foilTypes.length === 0) {
                    return null;
                }
                return this.rng.weightedChoice(this.foilTypes, this.foilWeights);
            }

            maybePlanFoil() {
                if (this.foilRate <= 0) return null;
                if (this.rng.next() < this.foilRate) {
                    const type = this.sampleFoilType();
                    return type ? { type } : null;
                }
                return null;
            }

            wouldRepeat(history, decision) {
                const window = [...history, decision];
                if (window.length < 24) return false;
                const recent = window.slice(-12);
                const previous = window.slice(-24, -12);
                return this.isRotationEqual(previous, recent);
            }

            isRotationEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) return false;
                const joined1 = arr1.join('');
                const joined2 = arr2.join('');
                return (joined1 + joined1).includes(joined2);
            }

            forceFlip(index) {
                if (index < 0 || index >= this.schedule.length) return;
                this.schedule[index] = !this.schedule[index];
                this.flips.set(index, true);
            }

            wasFlipped(index) {
                return this.flips.get(index) || false;
            }
        }

        class GameLogger {
            constructor(limitBytes = 5 * 1024 * 1024) {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeLimit = limitBytes;
                this.sizeEstimate = 0;
            }

            estimateSize(entry) {
                try {
                    return JSON.stringify(entry).length;
                } catch (error) {
                    return 0;
                }
            }

            flushToArchive() {
                const keep = Math.min(1000, this.entries.length);
                const flushCount = this.entries.length - keep;
                if (flushCount <= 0) return false;
                const flushedEntries = this.entries.splice(0, flushCount);
                const flushedSizes = this.entrySizes.splice(0, flushCount);
                this.archivedChunks.push(JSON.stringify(flushedEntries));
                const reclaimed = flushedSizes.reduce((acc, value) => acc + value, 0);
                this.sizeEstimate = Math.max(0, this.sizeEstimate - reclaimed);
                return true;
            }

            add(entry) {
                const size = this.estimateSize(entry);
                this.entries.push(entry);
                this.entrySizes.push(size);
                this.sizeEstimate += size;
                while (this.sizeEstimate > this.sizeLimit) {
                    const flushed = this.flushToArchive();
                    if (!flushed) {
                        break;
                    }
                }
            }

            reset() {
                this.entries = [];
                this.entrySizes = [];
                this.archivedChunks = [];
                this.sizeEstimate = 0;
            }

            getEntriesSnapshot() {
                const snapshot = [];
                for (const chunk of this.archivedChunks) {
                    try {
                        const parsed = JSON.parse(chunk);
                        if (Array.isArray(parsed)) {
                            snapshot.push(...parsed);
                        }
                    } catch (error) {
                        console.warn('Failed to parse archived log chunk', error);
                    }
                }
                snapshot.push(...this.entries);
                return snapshot;
            }

            toCSV() {
                const entries = this.getEntriesSnapshot();
                if (entries.length === 0) return '';
                const headers = Object.keys(entries[0]);
                const rows = [headers.join(',')];
                entries.forEach(entry => {
                    const row = headers.map(key => {
                        const value = entry[key];
                        if (value === null || value === undefined) return '';
                        if (typeof value === 'object') {
                            return JSON.stringify(value).replace(/"/g, '""');
                        }
                        return String(value).replace(/"/g, '""');
                    }).join(',');
                    rows.push(row);
                });
                return rows.join('\n');
            }

            toJSON() {
                return JSON.stringify(this.getEntriesSnapshot(), null, 2);
            }
        }

        class GameState {
            constructor(seed, options) {
                this.seed = seed;
                this.rng = new Mulberry32(seed);
                this.letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                this.windowSize = options.windowSize;
                this.currentStep = 0;
                this.constraintStore = [];
                this.premiseHistory = [];
                this.letterUsage = new Map();
                this.axisUsage = { N: 0, S: 0, E: 0, W: 0 };
                this.cooldown = new Map();
                this.novelty = new NoveltyManager(HAMMING_WINDOW, FIRST_N_NOVELTY);
                this.letterPool = new LetterPoolManager(this.letters, this.rng, this.letterUsage);
                this.coordinates = new Map();
            }

            resetNovelty() {
                this.novelty.reset();
            }

            getWindowAtoms() {
                const cutoff = Math.max(0, this.currentStep - this.windowSize);
                return this.constraintStore
                    .filter(entry => entry.step >= cutoff)
                    .flatMap(entry => entry.atoms);
            }

            getConstraintsInRange(start, end) {
                return this.constraintStore
                    .filter(entry => entry.step >= start && entry.step <= end)
                    .flatMap(entry => entry.atoms);
            }

            ensureLetterUsage(letter) {
                if (!this.letterUsage.has(letter)) {
                    this.letterUsage.set(letter, { head: 0, tail: 0 });
                }
                return this.letterUsage.get(letter);
            }

            updateUsage(premise) {
                premise.atoms.forEach(atom => {
                    this.ensureLetterUsage(atom.head).head += 1;
                    this.ensureLetterUsage(atom.tail).tail += 1;
                    this.axisUsage[atom.axis] += 1;
                });
            }

            recordPremise(premise, atoms, metadata) {
                this.constraintStore.push({ step: this.currentStep, atoms });
                this.premiseHistory.push({ step: this.currentStep, premise, metadata });
                this.currentStep += 1;

                const cutoff = this.currentStep - this.windowSize;
                this.constraintStore = this.constraintStore.filter(entry => entry.step >= cutoff);
                this.premiseHistory = this.premiseHistory.filter(entry => entry.step >= cutoff - this.windowSize);

                this.updateUsage(premise);
            }

            getPremiseAt(index) {
                const entry = this.premiseHistory.find(p => p.step === index);
                return entry ? entry.premise : null;
            }

            getActiveCooldown(currentTrial) {
                const active = new Set();
                this.cooldown.forEach((expiry, letter) => {
                    if (expiry > currentTrial) {
                        active.add(letter);
                    }
                });
                return active;
            }

            applyCooldown(letters, currentTrial, n) {
                const cooldownLength = Math.ceil(n / 2);
                letters.forEach(letter => {
                    this.cooldown.set(letter, currentTrial + cooldownLength);
                });
            }
        }

        class PremiseGenerator {
            constructor(state, solver, equivalence) {
                this.state = state;
                this.solver = solver;
                this.equivalence = equivalence;
                this.planner = null;
            }

            setPlanner(planner) {
                this.planner = planner;
            }

            generate(options) {
                const {
                    trialIndex,
                    k,
                    n,
                    plannedMatch,
                    nBackPremise,
                    middleAtoms,
                    avoidLetters,
                    allowOverride,
                    foilPlan
                } = options;

                const windowAtoms = this.state.getWindowAtoms();
                let bestCandidate = null;
                let attempts = 0;
                let expanded = false;
                const effectiveMatch = plannedMatch && Boolean(nBackPremise);
                let mode = effectiveMatch ? 'BSM' : 'ASNM';
                if (this.planner) {
                    mode = this.planner.chooseConflictMode(effectiveMatch);
                }

                let activeFoilPlan = (!effectiveMatch && foilPlan && typeof foilPlan.type === 'string') ? { type: foilPlan.type } : null;
                let foilAttempts = 0;

                while (attempts < MAX_GENERATION_ATTEMPTS) {
                    const expand = attempts > 0 && attempts % NOVELTY_OVERRIDE_THRESHOLD === 0;
                    if (expand) expanded = true;

                    let candidatePremise = null;
                    let candidateAtoms = null;
                    let modeUsed = mode;
                    let foilType = null;

                    if (!effectiveMatch && activeFoilPlan && nBackPremise) {
                        const foilResult = this.buildFoilPremise(activeFoilPlan.type, {
                            referencePremise: nBackPremise,
                            windowAtoms,
                            middleAtoms,
                            avoidLetters
                        });
                        foilAttempts++;
                        if (foilResult) {
                            candidatePremise = foilResult.premise;
                            candidateAtoms = candidatePremise.atoms;
                            foilType = foilResult.foilType;
                            modeUsed = `FOIL_${foilResult.foilType}`;
                        } else if (foilAttempts >= 60) {
                            activeFoilPlan = null;
                        }
                    }

                    if (!candidatePremise) {
                        const pool = this.state.letterPool.nextPool(k, { expand });
                        const context = {
                            mode,
                            plannedMatch: effectiveMatch,
                            nBackPremise,
                            pool,
                            k,
                            n,
                            trialIndex,
                            middleAtoms,
                            avoidLetters,
                            state: this.state,
                            rng: this.state.rng
                        };
                        const atomsFromMode = this.makePremiseWithMode(mode, context);
                        attempts++;
                        if (!atomsFromMode) {
                            if (attempts % 12 === 0 && this.planner) {
                                mode = this.planner.chooseConflictMode(effectiveMatch);
                            }
                            continue;
                        }
                        candidateAtoms = atomsFromMode;
                        candidatePremise = new Premise(atomsFromMode);
                    } else {
                        attempts++;
                        candidateAtoms = candidatePremise.atoms;
                    }

                    const premise = candidatePremise;
                    const features = premise.getFeatures();
                    const signatures = this.state.novelty.buildSignatures(premise);
                    const novelty = this.state.novelty.evaluate(premise, signatures, trialIndex);

                    if (novelty.blocked && !(allowOverride && expanded)) {
                        continue;
                    }

                    const satResult = this.solver.evaluate(windowAtoms, candidateAtoms);
                    if (!satResult.ok) {
                        continue;
                    }

                    let certificate = null;
                    let midDerivable = false;

                    if (effectiveMatch) {
                        const equivalence = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (!equivalence.match) {
                            continue;
                        }
                        certificate = equivalence.certificate;
                        midDerivable = equivalence.midWindowDerivable;
                    } else if (nBackPremise) {
                        const check = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms, windowAtoms);
                        if (check.match) {
                            continue;
                        }
                    }

                    const score = Math.exp(ACCEPTANCE_ALPHA * novelty.noveltyScores.hamming - ACCEPTANCE_BETA * novelty.penalty);
                    if (!bestCandidate || score > bestCandidate.score) {
                        bestCandidate = {
                            premise,
                            signatures,
                            novelty,
                            satResult,
                            certificate,
                            midDerivable,
                            attempts,
                            modeUsed,
                            features,
                            foilType,
                            score
                        };
                    }

                    if (this.state.rng.next() < Math.min(1, score)) {
                        return bestCandidate;
                    }

                    if (attempts % 12 === 0 && this.planner) {
                        mode = this.planner.chooseConflictMode(effectiveMatch);
                    }
                }

                return bestCandidate;
            }

            makePremiseWithMode(mode, context) {
                const requiresNBack = ['ASNM', 'APNM', 'PPHF', 'BSM', 'WLC', 'CAC', 'ISD'];
                if (!context.nBackPremise && requiresNBack.includes(mode)) {
                    return this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
                switch (mode) {
                    case 'ASNM':
                        return this.makeAxisSwapNearMiss(context);
                    case 'APNM':
                        return this.makeAnchorPermutationNearMiss(context);
                    case 'PPHF':
                        return this.makeParityPreservedHubFlip(context);
                    case 'CBB':
                        return this.makeCycleBorderBait(context);
                    case 'BSM':
                        return this.makeBipartiteSignatureMatch(context);
                    case 'WLC':
                        return this.makeWrongLagCamouflage(context);
                    case 'CAC':
                        return this.makeCrossAxisCoupling(context);
                    case 'ISD':
                        return this.makeIsomorphicSkeletonDecoy(context);
                    default:
                        return context.plannedMatch
                            ? this.buildMatchCandidate(context.nBackPremise, context.pool, context.k)
                            : this.buildNovelPremise(context.pool, context.k, context.avoidLetters);
                }
            }

            buildFoilPremise(type, context) {
                const { referencePremise, windowAtoms, middleAtoms, avoidLetters } = context;
                if (!referencePremise) return null;
                const maxAttempts = 80;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    let candidate = null;
                    switch (type) {
                        case 'ANCHOR_ONE':
                            candidate = this.makeAnchorOneFoil(referencePremise);
                            break;
                        case 'PAIR_SWAP':
                            candidate = this.makePairSwapFoil(referencePremise);
                            break;
                        case 'PARITY_OFF':
                            candidate = this.makeParityOffFoil(referencePremise);
                            break;
                        case 'AXIS_ORTHO':
                            candidate = this.makeAxisOrthoFoil(referencePremise);
                            break;
                        case 'DERIVED_IN_ONE':
                            candidate = this.makeDerivedInOneFoil(referencePremise);
                            break;
                        case 'WINDOW_SHADOW':
                            candidate = this.makeWindowShadowFoil(referencePremise, middleAtoms);
                            break;
                        default:
                            candidate = null;
                    }
                    if (!candidate) {
                        continue;
                    }
                    if (avoidLetters) {
                        const letters = candidate.getLetters();
                        let blocked = false;
                        avoidLetters.forEach(letter => {
                            if (letters.has(letter)) {
                                blocked = true;
                            }
                        });
                        if (blocked) continue;
                    }
                    const sat = this.solver.evaluate(windowAtoms, candidate.atoms);
                    if (!sat.ok) {
                        continue;
                    }
                    const eq = this.equivalence.Equivalent(referencePremise, candidate, windowAtoms, middleAtoms);
                    if (eq.ok) {
                        continue;
                    }
                    if (!this.foilReasonMatches(type, eq.reason)) {
                        continue;
                    }
                    return { premise: candidate, foilType: type };
                }
                return null;
            }

            foilReasonMatches(type, reason) {
                const expected = {
                    ANCHOR_ONE: 'anchors',
                    PAIR_SWAP: 'mapping',
                    PARITY_OFF: 'parity',
                    AXIS_ORTHO: 'mapping',
                    DERIVED_IN_ONE: 'parity',
                    WINDOW_SHADOW: 'mid-window-derivable'
                };
                const matchReason = expected[type];
                if (!matchReason) return true;
                if (matchReason === reason) return true;
                if (type === 'DERIVED_IN_ONE' && reason === 'mid-window-derivable') return true;
                return false;
            }

            makeAnchorOneFoil(referencePremise) {
                const refLetters = referencePremise.getLetters();
                const refArray = Array.from(refLetters);
                if (refArray.length === 0) return null;
                const anchor = this.state.rng.choice(refArray);
                const banned = new Set(refLetters);
                banned.delete(anchor);
                const available = this.state.letters.filter(letter => !banned.has(letter));
                if (available.length === 0) return null;
                const atoms = [];
                for (const atom of referencePremise.atoms) {
                    const axis = atom.axis;
                    const head = atom.head === anchor ? anchor : this.state.rng.choice(available);
                    let tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                    let guard = 0;
                    while (tail === head && guard < 12) {
                        tail = atom.tail === anchor ? anchor : this.state.rng.choice(available);
                        guard++;
                    }
                    if (tail === head) return null;
                    atoms.push(new Atom(axis, head, tail));
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refLetters.has(letter));
                if (shared.length !== 1 || shared[0] !== anchor) return null;
                return premise;
            }

            makePairSwapFoil(referencePremise) {
                const atoms = referencePremise.atoms;
                if (atoms.length < 2) return null;
                const heads = atoms.map(atom => atom.head);
                const tails = atoms.map(atom => atom.tail);
                for (let attempt = 0; attempt < 40; attempt++) {
                    const shuffledHeads = this.state.rng.shuffle(heads);
                    const shuffledTails = this.state.rng.shuffle(tails);
                    const candidates = [];
                    const usedKeys = new Set();
                    let valid = true;
                    for (let i = 0; i < atoms.length; i++) {
                        let head = shuffledHeads[i];
                        let tail = shuffledTails[i];
                        let guard = 0;
                        while (head === tail && guard < 8) {
                            tail = this.state.rng.choice(tails);
                            guard++;
                        }
                        if (head === tail) {
                            valid = false;
                            break;
                        }
                        const atomCandidate = new Atom(atoms[i].axis, head, tail);
                        const key = atomCandidate.toKey();
                        if (usedKeys.has(key)) {
                            valid = false;
                            break;
                        }
                        if (atomCandidate.equals(atoms[i]) || atomCandidate.equals(Atom.invert(atoms[i]))) {
                            valid = false;
                            break;
                        }
                        usedKeys.add(key);
                        candidates.push(atomCandidate);
                    }
                    if (!valid) continue;
                    const premise = new Premise(candidates);
                    if (premise.toKey() === referencePremise.toKey()) continue;
                    return premise;
                }
                return null;
            }

            makeParityOffFoil(referencePremise) {
                const refSet = referencePremise.getLetters();
                const refLetters = Array.from(refSet);
                const base = this.cloneAtoms(referencePremise);
                const originalLength = base.length;
                if (originalLength === 0) return null;
                let target = originalLength;
                if (originalLength === 1) {
                    target = Math.min(4, 2);
                } else if (originalLength === 4) {
                    target = 3;
                } else {
                    const delta = this.state.rng.next() < 0.5 ? -1 : 1;
                    target = Math.min(4, Math.max(1, originalLength + delta));
                    if (target === originalLength) {
                        target = Math.max(1, Math.min(4, originalLength - delta));
                    }
                    if (target === originalLength) {
                        target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                    }
                }
                if (target === originalLength) {
                    target = originalLength + 1 <= 4 ? originalLength + 1 : originalLength - 1;
                }
                if (target < 1) target = 1;
                let atoms = base;
                if (target < originalLength) {
                    atoms = base.slice();
                    while (atoms.length > target) {
                        const index = this.state.rng.nextInt(0, atoms.length - 1);
                        atoms.splice(index, 1);
                    }
                } else if (target > originalLength) {
                    atoms = base.slice();
                    const axes = MATCH_AXES;
                    let guard = 0;
                    while (atoms.length < target && guard < 60) {
                        guard++;
                        const head = this.state.rng.choice(refLetters);
                        let tail = this.state.rng.choice(refLetters);
                        if (tail === head) {
                            const alternative = this.sampleNewLetter(new Set([...refLetters]));
                            if (alternative) {
                                tail = alternative;
                            }
                        }
                        if (tail === head) continue;
                        const axis = this.state.rng.choice(axes);
                        const candidate = new Atom(axis, head, tail);
                        if (atoms.some(atom => atom.toKey() === candidate.toKey())) continue;
                        atoms.push(candidate);
                    }
                    if (atoms.length !== target) return null;
                }
                const premise = new Premise(atoms);
                const shared = Array.from(premise.getLetters()).filter(letter => refSet.has(letter));
                if (shared.length < 2) return null;
                return premise;
            }

            makeAxisOrthoFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const index = this.state.rng.nextInt(0, base.length - 1);
                const orthMap = { N: 'E', S: 'W', E: 'N', W: 'S' };
                const axis = orthMap[base[index].axis];
                if (!axis) return null;
                base[index] = new Atom(axis, base[index].head, base[index].tail);
                return new Premise(base);
            }

            makeDerivedInOneFoil(referencePremise) {
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const additions = [];
                for (let i = 0; i < base.length; i++) {
                    for (let j = 0; j < base.length; j++) {
                        if (i === j) continue;
                        const a = base[i];
                        const b = base[j];
                        if (a.axis !== b.axis) continue;
                        if (a.tail === b.head && a.head !== b.tail) {
                            const candidate = new Atom(a.axis, a.head, b.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                        if (b.tail === a.head && b.head !== a.tail) {
                            const candidate = new Atom(a.axis, b.head, a.tail);
                            if (candidate.head !== candidate.tail && !base.some(atom => atom.equals(candidate))) {
                                additions.push(candidate);
                            }
                        }
                    }
                }
                if (additions.length === 0) return null;
                base.push(this.state.rng.choice(additions));
                return new Premise(base);
            }

            makeWindowShadowFoil(referencePremise, middleAtoms) {
                if (!middleAtoms || middleAtoms.length === 0) return null;
                const base = this.cloneAtoms(referencePremise);
                if (base.length === 0) return null;
                const refLetters = referencePremise.getLetters();
                const options = middleAtoms.filter(atom => {
                    const already = base.some(existing => existing.equals(atom));
                    return !already && (refLetters.has(atom.head) || refLetters.has(atom.tail));
                });
                if (options.length === 0) return null;
                const replacement = this.state.rng.choice(options);
                const index = this.state.rng.nextInt(0, base.length - 1);
                base[index] = new Atom(replacement.axis, replacement.head, replacement.tail);
                return new Premise(base);
            }

            cloneAtoms(premise) {
                return premise.atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
            }

            sampleNewLetter(excludeSet = new Set()) {
                const candidates = this.state.letters.filter(letter => !excludeSet.has(letter));
                if (candidates.length === 0) return null;
                return this.state.rng.choice(candidates);
            }

            normalizeAtomCount(atoms, pool, target, avoidLetters, options = {}) {
                if (!atoms) return null;
                const clones = atoms.map(atom => new Atom(atom.axis, atom.head, atom.tail));
                const required = new Set();
                if (typeof options.requiredIndex === 'number') {
                    required.add(options.requiredIndex);
                }
                if (Array.isArray(options.requiredIndices)) {
                    options.requiredIndices.forEach(idx => required.add(idx));
                }

                const result = [];
                const usedKeys = new Set();
                const pushAtom = (atom) => {
                    const key = atom.toKey();
                    if (usedKeys.has(key)) return false;
                    result.push(atom);
                    usedKeys.add(key);
                    return true;
                };

                for (const idx of required) {
                    if (idx >= 0 && idx < clones.length) {
                        pushAtom(clones[idx]);
                    }
                }

                for (let i = 0; i < clones.length && result.length < target; i++) {
                    if (required.has(i)) continue;
                    pushAtom(clones[i]);
                }

                const poolLetters = pool.length > 0 ? pool : this.state.letters;
                let attempts = 0;
                while (result.length < target && attempts < 200) {
                    attempts++;
                    const head = this.state.rng.choice(poolLetters);
                    if (avoidLetters && avoidLetters.has(head)) continue;
                    let tailCandidates = poolLetters.filter(letter => letter !== head);
                    if (avoidLetters) {
                        tailCandidates = tailCandidates.filter(letter => !avoidLetters.has(letter));
                    }
                    if (tailCandidates.length === 0) continue;
                    const tail = this.state.rng.choice(tailCandidates);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    const atom = new Atom(axis, head, tail);
                    if (usedKeys.has(atom.toKey())) continue;
                    pushAtom(atom);
                }

                if (result.length !== target) return null;
                return result;
            }

            makeAxisSwapNearMiss({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise || nBackPremise.atoms.length === 0) return null;
                const base = this.cloneAtoms(nBackPremise);
                const index = this.state.rng.nextInt(0, base.length - 1);
                const axisOptions = MATCH_AXES.filter(axis => axis !== base[index].axis);
                if (axisOptions.length === 0) return null;
                base[index] = new Atom(this.state.rng.choice(axisOptions), base[index].head, base[index].tail);
                return this.normalizeAtomCount(base, pool, k, avoidLetters, { requiredIndex: index });
            }

            makeAnchorPermutationNearMiss({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length < 2) return null;
                const anchor = this.state.rng.choice(letters);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of letters) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, null);
            }

            makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters }) {
                if (!nBackPremise) return null;
                const counts = new Map();
                nBackPremise.atoms.forEach(atom => {
                    counts.set(atom.head, (counts.get(atom.head) || 0) + 1);
                    counts.set(atom.tail, (counts.get(atom.tail) || 0) + 1);
                });
                const sorted = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
                if (!sorted.length || sorted[0][1] < 2) return null;
                const hub = sorted[0][0];
                const exclude = new Set(nBackPremise.getLetters());
                let newHub = this.sampleNewLetter(exclude);
                if (!newHub) return null;
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = atom.head === hub ? newHub : atom.head;
                    const tail = atom.tail === hub ? newHub : atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeCycleBorderBait({ k, pool, avoidLetters }) {
                const uniquePool = Array.from(new Set(pool));
                const targetLetters = Math.max(3, Math.min(k + 1, 6));
                const letters = [];
                const used = new Set();
                const shuffled = this.state.rng.shuffle(uniquePool);
                for (const letter of shuffled) {
                    if (letters.length >= targetLetters) break;
                    letters.push(letter);
                    used.add(letter);
                }
                while (letters.length < targetLetters) {
                    const next = this.sampleNewLetter(used);
                    if (!next) break;
                    letters.push(next);
                    used.add(next);
                }
                if (letters.length < 3) return null;
                const axes = ['N', 'E', 'S', 'W'];
                const atoms = [];
                for (let i = 0; i < Math.min(k, letters.length - 1); i++) {
                    const axis = axes[i % axes.length];
                    atoms.push(new Atom(axis, letters[i], letters[i + 1]));
                }
                if (atoms.length < k) {
                    const axis = axes[atoms.length % axes.length];
                    const head = letters[letters.length - 1];
                    const tailIndex = letters.length > 2 ? 1 : 0;
                    atoms.push(new Atom(axis, head, letters[tailIndex]));
                }
                return this.normalizeAtomCount(atoms, pool, k, avoidLetters);
            }

            makeBipartiteSignatureMatch({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const targetFeatures = nBackPremise.getFeatures();
                for (let attempt = 0; attempt < 12; attempt++) {
                    const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    if (candidate.toKey() === nBackPremise.toKey()) continue;
                    if (!this.compareDegreeVectors(candidate.getFeatures().degreeVector, targetFeatures.degreeVector)) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeWrongLagCamouflage({ trialIndex, n, state, pool, k }) {
                let altPremise = null;
                if (n > 1) {
                    altPremise = state.getPremiseAt(trialIndex - (n - 1));
                }
                if (!altPremise) {
                    altPremise = state.getPremiseAt(trialIndex - (n + 1));
                }
                if (!altPremise) return null;
                for (let attempt = 0; attempt < 10; attempt++) {
                    const atoms = this.buildMatchCandidate(altPremise, pool, k);
                    if (!atoms) return null;
                    const candidate = new Premise(atoms);
                    const equivalence = this.equivalence.computeCertificate(altPremise, candidate, []);
                    if (!equivalence.match) {
                        continue;
                    }
                    return atoms;
                }
                return null;
            }

            makeCrossAxisCoupling(context) {
                const { nBackPremise, pool, k, plannedMatch, avoidLetters } = context;
                if (!nBackPremise) {
                    return plannedMatch
                        ? this.buildMatchCandidate(nBackPremise, pool, k)
                        : this.buildNovelPremise(pool, k, avoidLetters);
                }
                if (plannedMatch) {
                    for (let attempt = 0; attempt < 12; attempt++) {
                        const atoms = this.buildMatchCandidate(nBackPremise, pool, k);
                        if (!atoms) return null;
                        const candidate = new Premise(atoms);
                        if (candidate.toKey() === nBackPremise.toKey()) continue;
                        if (!this.hasCrossAxisCoupling(nBackPremise, candidate)) continue;
                        return atoms;
                    }
                    return null;
                }
                const atoms = this.makeParityPreservedHubFlip({ nBackPremise, k, pool, avoidLetters });
                if (!atoms) return null;
                const candidate = new Premise(atoms);
                return this.hasCrossAxisCoupling(nBackPremise, candidate) ? atoms : null;
            }

            makeIsomorphicSkeletonDecoy({ nBackPremise, k, pool }) {
                if (!nBackPremise) return null;
                const letters = Array.from(nBackPremise.getLetters());
                if (letters.length === 0) return null;
                const sorted = [...letters].sort();
                const anchor = this.state.rng.choice(sorted);
                const mapping = new Map();
                mapping.set(anchor, anchor);
                const used = new Set([anchor]);
                for (const letter of sorted) {
                    if (letter === anchor) continue;
                    let replacement = null;
                    let tries = 0;
                    while (tries < 80) {
                        tries++;
                        replacement = this.sampleNewLetter(new Set([...letters, ...used]));
                        if (!replacement || replacement === anchor) continue;
                        mapping.set(letter, replacement);
                        used.add(replacement);
                        break;
                    }
                    if (!mapping.has(letter)) return null;
                }
                const atoms = nBackPremise.atoms.map(atom => {
                    const head = mapping.get(atom.head) || atom.head;
                    const tail = mapping.get(atom.tail) || atom.tail;
                    return new Atom(atom.axis, head, tail);
                });
                const candidate = new Premise(atoms);
                if (candidate.isoSignature() !== nBackPremise.isoSignature()) {
                    return null;
                }
                return this.normalizeAtomCount(candidate.atoms, pool, k, null);
            }

            compareDegreeVectors(a, b) {
                if (a.size !== b.size) return false;
                for (const [letter, vecA] of a.entries()) {
                    const vecB = b.get(letter);
                    if (!vecB) return false;
                    for (let i = 0; i < vecA.length; i++) {
                        if (vecA[i] !== vecB[i]) return false;
                    }
                }
                return true;
            }

            collectAxisUsage(premise) {
                const usage = new Map();
                const mark = (letter, axis) => {
                    if (!usage.has(letter)) {
                        usage.set(letter, { vertical: false, horizontal: false });
                    }
                    const entry = usage.get(letter);
                    if (axis === 'N' || axis === 'S') {
                        entry.vertical = true;
                    } else {
                        entry.horizontal = true;
                    }
                };
                premise.atoms.forEach(atom => {
                    mark(atom.head, atom.axis);
                    mark(atom.tail, atom.axis);
                });
                return usage;
            }

            hasCrossAxisCoupling(p1, p2) {
                const usage1 = this.collectAxisUsage(p1);
                const usage2 = this.collectAxisUsage(p2);
                const letters = new Set([...usage1.keys(), ...usage2.keys()]);
                for (const letter of letters) {
                    const info1 = usage1.get(letter) || { vertical: false, horizontal: false };
                    const info2 = usage2.get(letter) || { vertical: false, horizontal: false };
                    if ((info1.vertical || info2.vertical) && (info1.horizontal || info2.horizontal)) {
                        return true;
                    }
                }
                return false;
            }

            buildMatchCandidate(nBackPremise, pool, k) {
                if (!nBackPremise) return null;
                const atoms = [];
                const nAtoms = nBackPremise.atoms;
                for (let i = 0; i < nAtoms.length; i++) {
                    const atom = nAtoms[i];
                    const invert = this.state.rng.next() < 0.6;
                    atoms.push(invert ? Atom.invert(atom) : new Atom(atom.axis, atom.head, atom.tail));
                }

                while (atoms.length < k) {
                    const head = this.state.rng.choice(pool);
                    const tailOptions = pool.filter(l => l !== head);
                    if (tailOptions.length === 0) break;
                    const tail = this.state.rng.choice(tailOptions);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    atoms.push(new Atom(axis, head, tail));
                }
                return atoms.slice(0, k);
            }

            buildNovelPremise(pool, k, avoidLetters) {
                const atoms = [];
                const usedPairs = new Set();
                const axisWeights = MATCH_AXES.map(axis => 1 / (1 + this.state.axisUsage[axis]));

                for (let i = 0; i < k; i++) {
                    let attempts = 0;
                    while (attempts < 40) {
                        let head = this.state.rng.choice(pool);
                        let tailCandidates = pool.filter(letter => letter !== head);
                        if (avoidLetters && avoidLetters.size > 0) {
                            const filtered = tailCandidates.filter(letter => !avoidLetters.has(letter));
                            if (filtered.length > 0) {
                                tailCandidates = filtered;
                            }
                            if (avoidLetters.has(head)) {
                                const alternatives = pool.filter(letter => !avoidLetters.has(letter));
                                if (alternatives.length > 0) {
                                    head = this.state.rng.choice(alternatives);
                                    tailCandidates = pool.filter(letter => letter !== head && !avoidLetters.has(letter));
                                }
                            }
                        }

                        if (tailCandidates.length === 0) break;
                        const tail = this.state.rng.choice(tailCandidates);
                        const pairKey = `${head}|${tail}`;
                        if (usedPairs.has(pairKey)) {
                            attempts++;
                            continue;
                        }

                        const axis = this.state.rng.weightedChoice(MATCH_AXES, axisWeights);
                        atoms.push(new Atom(axis, head, tail));
                        usedPairs.add(pairKey);
                        break;
                    }
                }

                return atoms.length === k ? atoms : null;
            }
        }

        class VoiceSynthesis {
            constructor() {
                this.synth = window.speechSynthesis;
                this.voice = null;
                this.voiceReady = false;
                this.pitch = 1.2;
                this.rate = 0.9;
                this.volume = 1.0;
                this.queue = [];
                this.isSpeaking = false;
                this.sessionToken = 0;
            }

            async initialize() {
                await new Promise(resolve => {
                    const attempt = () => {
                        const voices = this.synth.getVoices();
                        if (voices.length === 0) {
                            setTimeout(attempt, 200);
                            return;
                        }
                        this.selectVoice(voices);
                        this.voiceReady = true;
                        resolve();
                    };
                    attempt();
                });
            }

            selectVoice(voices) {
                const storedName = localStorage.getItem('relational-nback-voice-name');
                const storedLang = localStorage.getItem('relational-nback-voice-lang');

                if (storedName && storedLang) {
                    const stored = voices.find(v => v.name === storedName && v.lang === storedLang);
                    if (stored) {
                        this.voice = stored;
                        return;
                    }
                }

                const preferredLocales = ['en-AU', 'en-GB', 'en-US'];
                const feminineHints = ['Female', 'Karen', 'Natasha', 'Sonia', 'Serena', 'Aria', 'Samantha'];

                for (const locale of preferredLocales) {
                    const candidates = voices.filter(v => v.lang.startsWith(locale));
                    for (const hint of feminineHints) {
                        const match = candidates.find(v => v.name.includes(hint));
                        if (match) {
                            this.voice = match;
                            localStorage.setItem('relational-nback-voice-name', match.name);
                            localStorage.setItem('relational-nback-voice-lang', match.lang);
                            return;
                        }
                    }
                    if (candidates.length) {
                        this.voice = candidates[0];
                        return;
                    }
                }

                this.voice = voices[0] || null;
            }

            getVoiceInfo() {
                return this.voice ? `${this.voice.name} (${this.voice.lang})` : 'Voice not initialized';
            }

            speak(text, sessionToken) {
                return new Promise(resolve => {
                    this.queue.push({ text, resolve, sessionToken });
                    this.processQueue();
                });
            }

            async processQueue() {
                if (this.isSpeaking) return;
                const item = this.queue.shift();
                if (!item) return;

                this.isSpeaking = true;
                const utterance = new SpeechSynthesisUtterance(item.text);
                utterance.voice = this.voice;
                utterance.pitch = this.pitch;
                utterance.rate = this.rate;
                utterance.volume = this.volume;

                utterance.onend = () => {
                    this.isSpeaking = false;
                    item.resolve();
                    this.processQueue();
                };

                this.synth.speak(utterance);
            }

            async speakPremise(premise, sessionToken) {
                if (!premise) return;
                const text = premise.toNaturalSpeech();
                return this.speak(text, sessionToken);
            }

            async cancelAndWait() {
                this.synth.cancel();
                this.isSpeaking = false;
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        }

        class GameEngine {
            constructor() {
                this.session = sessionDefaults();
                this.seedManager = new SeedManager();
                this.logger = new GameLogger();
                this.voice = new VoiceSynthesis();
                this.state = null;
                this.solver = null;
                this.equivalence = new EquivalenceEngine(false);
                this.generator = null;
                this.planner = null;
                this.matchSchedule = [];
                this.awaitingResponse = false;
                this.sessionToken = 0;
                this.responseResolver = null;
                this.responseTimer = null;
                this.pendingTrialHandle = null;
                this.responseStartTime = 0;
                this.currentPremises = [];
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.M = 8;
                this.lockSeed = this.seedManager.getLockPreference();
                this.resetOnRestart = false;
                this.pendingPlannerFlip = false;
                this.pendingRestart = false;
                this.statusMessage = 'Idle';
            }

            get n() {
                return this.session.n;
            }

            set n(value) {
                this.session.n = value;
            }

            get k() {
                return this.session.k;
            }

            set k(value) {
                this.session.k = value;
            }

            get secondsPerTrial() {
                return this.session.secondsPerTrial;
            }

            set secondsPerTrial(value) {
                this.session.secondsPerTrial = value;
            }

            get totalTrials() {
                return this.session.numTrials;
            }

            set totalTrials(value) {
                this.session.numTrials = value;
            }

            applyNumTrialsFromUI() {
                const current = loadNumTrials();
                this.session.numTrials = current;
                return current;
            }

            clearAllTimers() {
                if (this.responseTimer) {
                    clearTimeout(this.responseTimer);
                    this.responseTimer = null;
                }
                if (this.pendingTrialHandle) {
                    clearTimeout(this.pendingTrialHandle);
                    this.pendingTrialHandle = null;
                }
            }

            speakOnce(text) {
                if (!text) return;
                this.voice.speak(text, this.sessionToken);
            }

            renderSummary() {
                this.statusMessage = `Session complete. ${this.session.numTrials} trials finished.`;
                document.getElementById('feedback').textContent = '';
            }

            scheduleNextTrial() {
                if (this.session.state !== 'RUNNING') return;
                if (this.pendingTrialHandle) {
                    clearTimeout(this.pendingTrialHandle);
                    this.pendingTrialHandle = null;
                }
                if (this.session.trialIndex >= this.session.numTrials) {
                    this.endSession();
                    return;
                }

                const token = this.sessionToken;
                this.pendingTrialHandle = setTimeout(async () => {
                    this.pendingTrialHandle = null;
                    if (token !== this.sessionToken || this.session.state !== 'RUNNING') {
                        return;
                    }
                    try {
                        await this.runTrial(token);
                        if (token === this.sessionToken) {
                            this.onTrialFinished();
                        }
                    } catch (error) {
                        console.error('Trial execution failed', error);
                        await this.stopSession(false);
                    }
                }, 0);
            }

            onTrialFinished() {
                if (this.session.state !== 'RUNNING') return;
                this.session.trialIndex += 1;
                this.updateUI();
                if (this.session.trialIndex >= this.session.numTrials) {
                    this.endSession();
                } else {
                    this.scheduleNextTrial();
                }
            }

            async stopSession(skipSummary = false) {
                const wasRunning = this.session.state === 'RUNNING' || this.session.state === 'PAUSED';
                this.session.state = 'STOPPED';
                this.sessionToken += 1;
                this.clearAllTimers();
                await this.voice.cancelAndWait();
                this.awaitingResponse = false;
                if (this.responseResolver) {
                    this.responseResolver(null);
                    this.responseResolver = null;
                }
                if (!skipSummary && wasRunning) {
                    this.statusMessage = 'Stopped';
                }
                this.updateUI();
            }

            async endSession() {
                this.session.state = 'STOPPED';
                this.clearAllTimers();
                if (window.speechSynthesis && typeof window.speechSynthesis.cancel === 'function') {
                    window.speechSynthesis.cancel();
                }
                await this.voice.cancelAndWait();
                this.awaitingResponse = false;
                if (this.responseResolver) {
                    this.responseResolver(null);
                    this.responseResolver = null;
                }
                const totalTrials = this.session.numTrials;
                this.speakOnce(`Session complete. ${totalTrials} trials finished.`);
                this.renderSummary();
                this.updateUI();
            }

            async restartSession() {
                this.pendingRestart = true;
                await this.stopSession(true);
                this.startSession();
            }

            async initialize() {
                await this.voice.initialize();
                this.updateVoiceInfo();
                this.attachUI();
                this.updateUI();
            }

            attachUI() {
                document.getElementById('lock-seed-toggle').checked = this.lockSeed;
                document.getElementById('lock-seed-toggle').addEventListener('change', (e) => {
                    this.lockSeed = e.target.checked;
                    this.seedManager.setLockPreference(this.lockSeed);
                });

                document.getElementById('reset-seed-toggle').addEventListener('change', (e) => {
                    this.resetOnRestart = e.target.checked;
                });

                document.getElementById('transitivity-toggle').addEventListener('change', (e) => {
                    this.equivalence.setTransitivity(e.target.checked);
                });

                document.getElementById('debug-toggle').addEventListener('change', (e) => {
                    document.getElementById('debug').hidden = !e.target.checked;
                });

                const sptSlider = document.getElementById('spt-slider');
                const sptNumber = document.getElementById('spt-number');
                const syncSeconds = (value) => {
                    this.secondsPerTrial = parseFloat(value);
                    document.getElementById('spt-value').textContent = this.secondsPerTrial.toFixed(1);
                };
                sptSlider.addEventListener('input', (e) => {
                    sptNumber.value = e.target.value;
                    syncSeconds(e.target.value);
                });
                sptNumber.addEventListener('input', (e) => {
                    sptSlider.value = e.target.value;
                    syncSeconds(e.target.value);
                });

                document.getElementById('n-slider').addEventListener('input', (e) => {
                    this.n = parseInt(e.target.value, 10);
                    document.getElementById('n-value').textContent = this.n;
                });

                document.getElementById('k-slider').addEventListener('input', (e) => {
                    this.k = parseInt(e.target.value, 10);
                    document.getElementById('k-value').textContent = this.k;
                });

                document.getElementById('start-btn').addEventListener('click', () => {
                    this.pendingRestart = false;
                    this.startSession();
                });
                document.getElementById('restart-btn').addEventListener('click', () => {
                    this.restartSession();
                });
                document.getElementById('stop-btn').addEventListener('click', () => {
                    this.stopSession(false);
                });
                document.getElementById('match-btn').addEventListener('click', () => this.handleResponse(true));
                document.getElementById('no-match-btn').addEventListener('click', () => this.handleResponse(false));
                document.getElementById('repeat-btn').addEventListener('click', () => this.handleRepeat());

                document.getElementById('preview-btn').addEventListener('click', async () => {
                    const previewPremise = new Premise([
                        new Atom('N', 'A', 'B'),
                        new Atom('E', 'C', 'D')
                    ]);
                    await this.voice.speakPremise(previewPremise, 0);
                });

                document.addEventListener('keydown', (e) => {
                    if (!this.awaitingResponse) return;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.handleResponse(true);
                    } else if (e.code === 'Enter') {
                        e.preventDefault();
                        this.handleResponse(false);
                    }
                });

                document.getElementById('export-btn').addEventListener('click', () => {
                    this.exportData();
                });

                document.getElementById('test-btn').addEventListener('click', async () => {
                    const panel = document.getElementById('test-panel');
                    const resultsEl = document.getElementById('test-results');
                    panel.hidden = false;
                    resultsEl.innerHTML = '<p>Running tests...</p>';
                    const harness = new TestHarness();
                    const results = await harness.runAll();
                    resultsEl.innerHTML = results.map(result => {
                        const cls = result.passed ? 'pass' : 'fail';
                        const symbol = result.passed ? 'âœ“' : 'âœ—';
                        return `<div class="test-result ${cls}">${symbol} ${result.test}: ${result.details}</div>`;
                    }).join('');
                });
            }

            updateVoiceInfo() {
                document.getElementById('voice-info').innerHTML = `<strong>Voice:</strong> ${this.voice.getVoiceInfo()}`;
            }

            updateUI() {
                document.getElementById('trial-count').textContent = this.session.trialIndex;
                document.getElementById('score').textContent = this.score;
                document.getElementById('omissions').textContent = this.omissions;
                const accuracy = this.totalResponses > 0 ? (this.correctResponses / this.totalResponses) * 100 : null;
                document.getElementById('accuracy').textContent = accuracy !== null ? `${accuracy.toFixed(1)}%` : '-';
                const rolling = this.recentAccuracy.length > 0
                    ? (this.recentAccuracy.reduce((a, b) => a + b, 0) / this.recentAccuracy.length) * 100
                    : null;
                document.getElementById('rolling-acc').textContent = rolling !== null ? `${rolling.toFixed(1)}%` : '-';

                const running = this.session.state === 'RUNNING';
                const statusText = running ? `Running (n=${this.n}, k=${this.k})` : this.statusMessage;
                document.getElementById('status').textContent = statusText;

                document.getElementById('start-btn').disabled = running;
                document.getElementById('restart-btn').disabled = !running;
                document.getElementById('stop-btn').disabled = !running;
            }

            startSession() {
                if (this.session.state === 'RUNNING') return;
                this.session = sessionDefaults();
                const totalPlanned = this.applyNumTrialsFromUI();
                this.session.trialIndex = 0;
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.pendingPlannerFlip = false;

                const shouldResetLogs = !this.pendingRestart || this.resetOnRestart;
                this.pendingRestart = false;

                const seed = this.seedManager.generateSessionSeed(this.lockSeed);
                this.session.seedSession = seed;
                this.state = new GameState(seed, { windowSize: Math.max(2 * this.n + 2, 12) });
                this.state.resetNovelty();
                this.solver = new ConstraintSolver();
                this.generator = new PremiseGenerator(this.state, this.solver, this.equivalence);
                this.planner = new MatchPlanner(this.state.rng);
                this.generator.setPlanner(this.planner);
                this.matchSchedule = this.planner.plan(totalPlanned, this.n);
                if (shouldResetLogs) {
                    this.logger.reset();
                }
                this.currentPremises = [];
                this.statusMessage = `Running (n=${this.n}, k=${this.k})`;
                this.session.state = 'RUNNING';
                this.sessionToken += 1;

                this.updateUI();
                this.scheduleNextTrial();
            }

            async runTrial(sessionToken) {
                if (this.session.state !== 'RUNNING' || sessionToken !== this.sessionToken) return;

                const currentIndex = this.session.trialIndex;
                const scheduledMatch = this.matchSchedule[currentIndex] || false;
                const nBackIndex = currentIndex - this.n;
                const nBackPremise = nBackIndex >= 0 ? this.currentPremises[nBackIndex] : null;
                const middleAtoms = nBackIndex >= 0 ? this.state.getConstraintsInRange(nBackIndex + 1, currentIndex - 1) : [];
                const cooldown = this.state.getActiveCooldown(currentIndex);

                let planMatch = scheduledMatch && Boolean(nBackPremise);
                let foilPlan = (!planMatch && nBackPremise) ? this.planner.maybePlanFoil() : null;

                let result = this.generator.generate({
                    trialIndex: currentIndex,
                    k: this.k,
                    n: this.n,
                    plannedMatch: planMatch,
                    nBackPremise,
                    middleAtoms,
                    avoidLetters: planMatch ? cooldown : null,
                    allowOverride: true,
                    foilPlan
                });

                let plannerFlip = false;

                if (!result && scheduledMatch) {
                    this.planner.forceFlip(currentIndex);
                    plannerFlip = true;
                    planMatch = false;
                    foilPlan = nBackPremise ? this.planner.maybePlanFoil() : null;
                    result = this.generator.generate({
                        trialIndex: currentIndex,
                        k: this.k,
                        n: this.n,
                        plannedMatch: false,
                        nBackPremise,
                        middleAtoms,
                        avoidLetters: null,
                        allowOverride: true,
                        foilPlan
                    });
                }

                if (!result) {
                    await this.stopSession(false);
                    return;
                }

                const { premise, signatures, novelty, satResult, certificate, modeUsed, features, foilType } = result;
                const planType = planMatch
                    ? 'match'
                    : (foilType ? `foil:${foilType}` : 'nonmatch');
                const featureSnapshot = features || premise.getFeatures();
                this.currentPremises.push(premise);
                this.state.recordPremise(premise, premise.atoms, { plannedMatch: planMatch, certificate, modeUsed, foilType });
                this.state.novelty.register(signatures);
                this.state.coordinates = satResult.coordinates;

                document.getElementById('premise-display').textContent = premise.toString();
                await this.voice.speakPremise(premise, sessionToken);
                if (sessionToken !== this.sessionToken) return;

                this.awaitingResponse = true;
                this.responseStartTime = Date.now();

                const response = await new Promise(resolve => {
                    this.responseResolver = resolve;
                    document.getElementById('match-btn').disabled = false;
                    document.getElementById('no-match-btn').disabled = false;
                    document.getElementById('repeat-btn').disabled = false;
                    this.responseTimer = setTimeout(() => {
                        if (this.responseResolver) {
                            this.responseResolver(null);
                            this.responseResolver = null;
                        }
                    }, this.secondsPerTrial * 1000);
                });

                if (sessionToken !== this.sessionToken) return;

                this.awaitingResponse = false;
                if (this.responseTimer) {
                    clearTimeout(this.responseTimer);
                    this.responseTimer = null;
                }
                document.getElementById('match-btn').disabled = true;
                document.getElementById('no-match-btn').disabled = true;
                document.getElementById('repeat-btn').disabled = true;

                const actualMatch = Boolean(planMatch && certificate);
                let correct = false;
                let omission = false;

                if (response === null) {
                    omission = true;
                    this.omissions += 1;
                } else {
                    correct = response === actualMatch;
                    if (correct) {
                        this.score += 1;
                        this.correctResponses += 1;
                    }
                    this.totalResponses += 1;
                    this.recentAccuracy.push(correct ? 1 : 0);
                    if (this.recentAccuracy.length > this.M) {
                        this.recentAccuracy.shift();
                    }
                }

                const rt = response === null ? null : Date.now() - this.responseStartTime;
                const feedbackEl = document.getElementById('feedback');
                if (omission) {
                    feedbackEl.textContent = 'Response window expired.';
                    feedbackEl.className = 'feedback incorrect';
                } else if (correct) {
                    feedbackEl.textContent = 'Correct';
                    feedbackEl.className = 'feedback correct';
                } else {
                    feedbackEl.textContent = 'Incorrect';
                    feedbackEl.className = 'feedback incorrect';
                }

                if (actualMatch && certificate) {
                    this.state.applyCooldown(Array.from(premise.getLetters()), currentIndex, this.n);
                }

                const featureLog = {
                    lettersSet: Array.from(featureSnapshot.lettersSet).sort(),
                    degreeVector: {},
                    skeletonIsoSignature: featureSnapshot.skeletonIsoSignature,
                    atomAxisProfile: {}
                };
                featureSnapshot.degreeVector.forEach((vec, letter) => {
                    featureLog.degreeVector[letter] = [...vec];
                });
                featureSnapshot.atomAxisProfile.forEach((count, axis) => {
                    featureLog.atomAxisProfile[axis] = count;
                });

                const logEntry = {
                    seedSession: this.seedManager.sessionSeed,
                    trialIndex: currentIndex,
                    trialNumber: currentIndex + 1,
                    numTrials: this.session.numTrials,
                    n: this.n,
                    k: this.k,
                    letters: Array.from(premise.getLetters()).join(''),
                    atomsCanonical: premise.toKey(),
                    atomsMirrorCanonical: premise.mirrorKey(),
                    isoSignature: premise.isoSignature(),
                    plannedMatch: planMatch,
                    planType,
                    foilType: foilType || null,
                    certificate: certificate || null,
                    satStatus: satResult.ok,
                    midWindowDerivable: certificate ? certificate.midWindowDerivable : false,
                    noveltyScores: novelty.noveltyScores,
                    response: { choice: response, correct, rtMs: rt, omission },
                    cooldownLetters: Array.from(this.state.getActiveCooldown(currentIndex + 1)),
                    plannerFlip: plannerFlip || this.planner.wasFlipped(currentIndex),
                    modeUsed,
                    features: featureLog
                };

                this.logger.add(logEntry);
                this.updateDebugPanel(logEntry);
            }

            updateDebugPanel(entry) {
                const debug = document.getElementById('debug-content');
                const el = document.createElement('div');
                el.className = 'debug-premise';
                el.textContent = `Trial ${entry.trialIndex}: ${entry.atomsCanonical} | Plan=${entry.planType} | Response=${entry.response.choice}`;
                debug.prepend(el);
                while (debug.childElementCount > 20) {
                    debug.removeChild(debug.lastChild);
                }
            }

            handleResponse(isMatch) {
                if (!this.awaitingResponse || !this.responseResolver) return;
                if (this.responseTimer) {
                    clearTimeout(this.responseTimer);
                    this.responseTimer = null;
                }
                this.responseResolver(isMatch);
                this.responseResolver = null;
            }

            async handleRepeat() {
                if (!this.awaitingResponse) return;
                if (this.responseTimer) {
                    clearTimeout(this.responseTimer);
                    this.responseTimer = null;
                }
                await this.voice.cancelAndWait();
                await this.voice.speakPremise(this.currentPremises[this.session.trialIndex], this.sessionToken);
                if (!this.awaitingResponse) return;
                this.responseStartTime = Date.now();
                this.responseTimer = setTimeout(() => {
                    if (this.responseResolver) {
                        this.responseResolver(null);
                        this.responseResolver = null;
                    }
                }, this.secondsPerTrial * 1000);
            }

            exportData() {
                const data = {
                    seedSession: this.seedManager.sessionSeed,
                    entries: this.logger.getEntriesSnapshot()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `imagi-world-session-${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        class TestHarness {
            constructor() {
                this.seedManager = new SeedManager();
            }

            async runAll() {
                return [
                    await this.testNovelty(),
                    await this.testContradictions(),
                    await this.testCertificate(),
                    await this.testInputGating(),
                    await this.testProofExamples()
                ];
            }

            async testNovelty() {
                const seeds = [];
                const firstPremises = new Set();
                for (let i = 0; i < 5; i++) {
                    const seed = this.seedManager.generateSessionSeed(false);
                    seeds.push(seed);
                    const state = new GameState(seed, { windowSize: 12 });
                    const solver = new ConstraintSolver();
                    const eq = new EquivalenceEngine(false);
                    const generator = new PremiseGenerator(state, solver, eq);
                    let unique = true;
                    for (let trial = 0; trial < FIRST_N_NOVELTY; trial++) {
                        const result = generator.generate({
                            trialIndex: trial,
                            k: 2,
                            n: 2,
                            plannedMatch: false,
                            nBackPremise: null,
                            middleAtoms: [],
                            avoidLetters: null,
                            allowOverride: false
                        });
                        if (!result) {
                            unique = false;
                            break;
                        }
                        const key = result.premise.toKey();
                        if (firstPremises.has(key)) {
                            unique = false;
                        }
                        firstPremises.add(key);
                        state.novelty.register(state.novelty.buildSignatures(result.premise));
                    }
                }
                return {
                    test: 'Novelty',
                    passed: firstPremises.size >= seeds.length * FIRST_N_NOVELTY,
                    details: 'First six premises differ across restarts'
                };
            }

            async testContradictions() {
                const state = new GameState(12345, { windowSize: 12 });
                const solver = new ConstraintSolver();
                const atoms = [new Atom('N', 'A', 'B'), new Atom('S', 'A', 'B')];
                const sat = solver.evaluate([], atoms);
                return {
                    test: 'Constraint contradictions',
                    passed: !sat.ok,
                    details: 'Opposite relations rejected by SAT core'
                };
            }

            async testCertificate() {
                const premiseA = new Premise([new Atom('N', 'A', 'B'), new Atom('W', 'A', 'C')]);
                const premiseB = new Premise([new Atom('S', 'B', 'A'), new Atom('E', 'C', 'A')]);
                const eq = new EquivalenceEngine(false);
                const certificate = eq.computeCertificate(premiseA, premiseB, []);
                return {
                    test: 'Certificate generation',
                    passed: certificate.match && certificate.certificate.mapping.length === 2,
                    details: 'Invertible mapping generated for 2-atom pair'
                };
            }

            async testInputGating() {
                const engine = new GameEngine();
                await engine.voice.initialize();
                engine.totalTrials = 0;
                engine.correctResponses = 0;
                engine.totalResponses = 0;
                engine.omissions = 3;
                engine.awaitingResponse = false;
                const before = engine.score;
                engine.handleResponse(true);
                return {
                    test: 'Input gating',
                    passed: engine.score === before,
                    details: 'No score change without active response window'
                };
            }

            async testProofExamples() {
                const eq = new EquivalenceEngine(false);
                const p1 = new Premise([new Atom('N', 'A', 'B')]);
                const mid = [new Atom('N', 'B', 'C')];
                const p2 = new Premise([new Atom('N', 'A', 'C')]);
                const cert = eq.computeCertificate(p1, p2, mid);
                return {
                    test: 'Proof-based equivalence',
                    passed: !cert.match,
                    details: 'Mid-window derivable relation rejected when transitivity off'
                };
            }
        }

        const engine = new GameEngine();
        engine.initialize();
    </script>
</body>
</html>
