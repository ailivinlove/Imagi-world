<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imagi-world</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            margin: 20px 0;
            font-size: 2rem;
            text-align: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .controls {
            background: #16213e;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #e94560;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        input[type="range"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            background: #0f3460;
            color: #eee;
            border: 1px solid #1a4d7a;
            border-radius: 6px;
            font-size: 1rem;
            margin-left: 10px;
        }

        input[type="number"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .range-value {
            display: inline-block;
            min-width: 30px;
            text-align: right;
            font-weight: bold;
            color: #e94560;
        }

        .dual-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .dual-control input[type="range"] {
            flex: 1;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        button:hover {
            background: #d63651;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(233, 69, 96, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: #0f3460;
        }

        button.secondary:hover:not(:disabled) {
            background: #1a4d7a;
        }

        button.danger {
            background: #c0392b;
        }

        button.danger:hover:not(:disabled) {
            background: #a93226;
        }

        button.success {
            background: #27ae60;
        }

        button.success:hover:not(:disabled) {
            background: #229954;
        }

        .game-area {
            background: #16213e;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .status {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            width: 100%;
        }

        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #e94560;
        }

        .response-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .response-buttons button {
            flex: 1;
            padding: 20px;
            font-size: 1.2rem;
        }

        .match-btn {
            background: #2ecc71;
        }

        .match-btn:hover:not(:disabled) {
            background: #27ae60;
        }

        .no-match-btn {
            background: #e74c3c;
        }

        .no-match-btn:hover:not(:disabled) {
            background: #c0392b;
        }

        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1.1rem;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .feedback.correct {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .feedback.incorrect {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        #debug {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 400px;
            overflow-y: auto;
        }

        #debug h3 {
            margin-bottom: 15px;
            color: #e94560;
        }

        .debug-premise {
            margin-bottom: 10px;
            padding: 8px;
            background: #16213e;
            border-radius: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"]:focus {
            outline: 2px solid #e94560;
            outline-offset: 2px;
        }

        .voice-info {
            background: #0f3460;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 10px;
        }

        .voice-info strong {
            color: #e94560;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .test-panel {
            background: #0a0e1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .test-result {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .test-result.pass {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
        }

        .test-result.fail {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .premise-display {
            font-size: 1.3rem;
            color: #aaa;
            margin: 20px 0;
            min-height: 60px;
            font-style: italic;
        }

        @media (max-width: 600px) {
            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .response-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒ€Imagi-worldðŸŒ€</h1>

        <div class="controls">
            <div class="control-group">
                <label>N-Back Level: <span class="range-value" id="n-value">2</span></label>
                <input type="range" id="n-slider" min="1" max="5" value="2">
            </div>

            <div class="control-group">
                <label>Atoms per Premise (k): <span class="range-value" id="k-value">1</span></label>
                <input type="range" id="k-slider" min="1" max="4" value="1">
            </div>

            <div class="control-group">
                <label>Seconds per Trial: <span class="range-value" id="spt-value">6.0</span> s</label>
                <div class="dual-control">
                    <input type="range" id="spt-slider" min="2" max="20" step="0.5" value="6.0">
                    <input type="number" id="spt-number" min="2" max="20" step="0.5" value="6.0">
                </div>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="transitivity-toggle">
                <label for="transitivity-toggle" style="margin-bottom: 0;">Enable Advanced Transitivity</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="lock-seed-toggle">
                <label for="lock-seed-toggle" style="margin-bottom: 0;">Lock seed (reuse until unlocked)</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="reset-seed-toggle">
                <label for="reset-seed-toggle" style="margin-bottom: 0;">Reset stats & logs on Restart</label>
            </div>

            <div class="control-group checkbox-group">
                <input type="checkbox" id="debug-toggle">
                <label for="debug-toggle" style="margin-bottom: 0;">Show Debug Panel</label>
            </div>

            <div style="margin-top: 20px;">
                <div class="button-group">
                    <button id="start-btn" class="success">Start</button>
                    <button id="restart-btn" class="success" disabled>Restart</button>
                    <button id="stop-btn" class="danger" disabled>Stop</button>
                    <button id="repeat-btn" class="secondary" disabled>Repeat Audio</button>
                    <button id="preview-btn" class="secondary">Voice Preview</button>
                </div>
                <div class="button-group">
                    <button id="test-btn" class="secondary">Run Tests</button>
                    <button id="export-btn" class="secondary">Export Data</button>
                </div>
            </div>

            <div class="voice-info" id="voice-info">Initializing voice...</div>
        </div>

        <div class="game-area">
            <div class="status" id="status">Preparing voice system...</div>
            <div class="premise-display" id="premise-display"></div>

            <div class="response-buttons">
                <button class="match-btn" id="match-btn" disabled>
                    MATCH<br><small>(Spacebar)</small>
                </button>
                <button class="no-match-btn" id="no-match-btn" disabled>
                    NO MATCH<br><small>(Enter)</small>
                </button>
            </div>

            <div class="feedback" id="feedback"></div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Trial</div>
                    <div class="stat-value" id="trial-count">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Accuracy</div>
                    <div class="stat-value" id="accuracy">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Rolling Acc.</div>
                    <div class="stat-value" id="rolling-acc">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Omissions</div>
                    <div class="stat-value" id="omissions">0</div>
                </div>
            </div>
        </div>

        <div id="debug" hidden>
            <h3>Debug Panel - Last Premises</h3>
            <div id="debug-content"></div>
        </div>

        <div id="test-panel" class="test-panel" hidden>
            <h3>Test Results</h3>
            <div id="test-results"></div>
        </div>
    </div>

    <script type="module">
        const RELATION_WORDS = { N: 'north of', S: 'south of', E: 'east of', W: 'west of' };
        const MATCH_AXES = ['N', 'S', 'E', 'W'];
        const ACCEPTANCE_ALPHA = 0.25;
        const ACCEPTANCE_BETA = 0.5;
        const FIRST_N_NOVELTY = 6;
        const HAMMING_WINDOW = 8;
        const NOVELTY_OVERRIDE_THRESHOLD = 30;
        const MAX_GENERATION_ATTEMPTS = 240;

        function cryptoRandom32() {
            if (window.crypto && window.crypto.getRandomValues) {
                const arr = new Uint32Array(1);
                window.crypto.getRandomValues(arr);
                return arr[0] >>> 0;
            }

            let x = Date.now() ^ Math.floor(Math.random() * 0xffffffff);
            x ^= x << 13;
            x ^= x >>> 17;
            x ^= x << 5;
            return x >>> 0;
        }

        function fnv1aHash(parts) {
            let hash = 0x811c9dc5;
            for (const part of parts) {
                const value = (part >>> 0);
                hash ^= value;
                hash = Math.imul(hash, 0x01000193);
            }
            return hash >>> 0;
        }

        class Mulberry32 {
            constructor(seed) {
                this.state = seed >>> 0;
            }

            next() {
                let t = this.state += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }

            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }

            choice(array) {
                return array[Math.floor(this.next() * array.length)];
            }

            shuffle(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(this.next() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            weightedChoice(items, weights) {
                const cumulative = [];
                let total = 0;
                for (const weight of weights) {
                    total += weight;
                    cumulative.push(total);
                }
                const r = this.next() * total;
                for (let i = 0; i < cumulative.length; i++) {
                    if (r <= cumulative[i]) return items[i];
                }
                return items[items.length - 1];
            }

            nextBetween(min, max) {
                return min + (max - min) * this.next();
            }
        }

        class SeedManager {
            constructor() {
                this.runCounterKey = 'relational-nback-run-counter';
                this.seedKey = 'relational-nback-last-seed';
                this.lockKey = 'relational-nback-lock-seed';
                this.sessionSeed = null;
                this.runCounter = this.loadRunCounter();
            }

            loadRunCounter() {
                const raw = localStorage.getItem(this.runCounterKey);
                const parsed = raw ? parseInt(raw, 10) : 0;
                return Number.isFinite(parsed) ? parsed : 0;
            }

            getLockPreference() {
                return localStorage.getItem(this.lockKey) === 'true';
            }

            setLockPreference(lock) {
                localStorage.setItem(this.lockKey, lock ? 'true' : 'false');
            }

            incrementRunCounter() {
                this.runCounter += 1;
                localStorage.setItem(this.runCounterKey, String(this.runCounter));
                return this.runCounter;
            }

            generateSessionSeed(lockSeed) {
                if (lockSeed) {
                    const existing = localStorage.getItem(this.seedKey);
                    if (existing) {
                        this.sessionSeed = parseInt(existing, 10) >>> 0;
                        return this.sessionSeed;
                    }
                }

                const counter = this.incrementRunCounter();
                const random = cryptoRandom32();
                const salt = Date.now() >>> 0;
                const seed = fnv1aHash([counter, random, salt]);
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
                return seed;
            }

            persistSessionSeed(seed) {
                this.sessionSeed = seed;
                localStorage.setItem(this.seedKey, String(seed));
            }
        }

        class DisjointSet {
            constructor(elements = []) {
                this.parent = new Map();
                this.rank = new Map();
                elements.forEach(e => this.makeSet(e));
            }

            makeSet(x) {
                if (!this.parent.has(x)) {
                    this.parent.set(x, x);
                    this.rank.set(x, 0);
                }
            }

            find(x) {
                if (!this.parent.has(x)) {
                    this.makeSet(x);
                }
                const parent = this.parent.get(x);
                if (parent !== x) {
                    const root = this.find(parent);
                    this.parent.set(x, root);
                    return root;
                }
                return x;
            }

            union(x, y) {
                const rootX = this.find(x);
                const rootY = this.find(y);
                if (rootX === rootY) return rootX;

                const rankX = this.rank.get(rootX) || 0;
                const rankY = this.rank.get(rootY) || 0;

                if (rankX < rankY) {
                    this.parent.set(rootX, rootY);
                    return rootY;
                } else if (rankX > rankY) {
                    this.parent.set(rootY, rootX);
                    return rootX;
                } else {
                    this.parent.set(rootY, rootX);
                    this.rank.set(rootX, rankX + 1);
                    return rootX;
                }
            }

            getSets() {
                const result = new Map();
                for (const key of this.parent.keys()) {
                    const root = this.find(key);
                    if (!result.has(root)) {
                        result.set(root, new Set());
                    }
                    result.get(root).add(key);
                }
                return result;
            }
        }

        class Atom {
            constructor(axis, head, tail) {
                this.axis = axis;
                this.head = head;
                this.tail = tail;
            }

            equals(other) {
                return this.axis === other.axis && this.head === other.head && this.tail === other.tail;
            }

            toString() {
                return `${this.head} is ${RELATION_WORDS[this.axis]} ${this.tail}`;
            }

            toKey() {
                return `${this.axis},${this.head},${this.tail}`;
            }

            static invert(atom) {
                const invMap = { N: 'S', S: 'N', E: 'W', W: 'E' };
                return new Atom(invMap[atom.axis], atom.tail, atom.head);
            }
        }

        class Premise {
            constructor(atoms) {
                this.atoms = [...atoms].sort((a, b) => {
                    if (a.axis !== b.axis) return a.axis.localeCompare(b.axis);
                    if (a.head !== b.head) return a.head.localeCompare(b.head);
                    return a.tail.localeCompare(b.tail);
                });
            }

            getLetters() {
                const letters = new Set();
                this.atoms.forEach(atom => {
                    letters.add(atom.head);
                    letters.add(atom.tail);
                });
                return letters;
            }

            atomKeys() {
                return this.atoms.map(atom => atom.toKey());
            }

            toKey() {
                return this.atomKeys().join('|');
            }

            toString() {
                return this.atoms.map(a => a.toString()).join('; ');
            }

            toNaturalSpeech() {
                return this.atoms.map(atom => `${atom.head} is ${RELATION_WORDS[atom.axis]} ${atom.tail}`).join('; ') + '.';
            }

            mirrorKey() {
                const canonicalAtoms = this.atoms.map(atom => {
                    const inverted = Atom.invert(atom);
                    const current = `${atom.axis}|${atom.head}|${atom.tail}`;
                    const flipped = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return current < flipped ? current : flipped;
                }).sort();
                return canonicalAtoms.join('|');
            }

            isoSignature() {
                const letterMap = new Map();
                let nextCharCode = 'a'.charCodeAt(0);
                const normalized = this.atoms.map(atom => {
                    if (!letterMap.has(atom.head)) {
                        letterMap.set(atom.head, String.fromCharCode(nextCharCode++));
                    }
                    if (!letterMap.has(atom.tail)) {
                        letterMap.set(atom.tail, String.fromCharCode(nextCharCode++));
                    }
                    const headNorm = letterMap.get(atom.head);
                    const tailNorm = letterMap.get(atom.tail);
                    const normalizedAtom = new Atom(atom.axis, headNorm, tailNorm);
                    const inverted = Atom.invert(normalizedAtom);
                    const keyCurrent = `${normalizedAtom.axis}|${normalizedAtom.head}|${normalizedAtom.tail}`;
                    const keyInv = `${inverted.axis}|${inverted.head}|${inverted.tail}`;
                    return keyCurrent < keyInv ? keyCurrent : keyInv;
                });
                return normalized.sort().join('|');
            }
        }

        class NoveltyManager {
            constructor(windowSize = HAMMING_WINDOW, firstN = FIRST_N_NOVELTY) {
                this.windowSize = windowSize;
                this.firstN = firstN;
                this.seenExact = new Set();
                this.seenMirror = new Set();
                this.seenIso = new Set();
                this.history = [];
            }

            buildSignatures(premise) {
                return {
                    exact: premise.toKey(),
                    mirror: premise.mirrorKey(),
                    iso: premise.isoSignature(),
                    atoms: premise.atomKeys()
                };
            }

            computeHamming(atoms) {
                if (this.history.length === 0) return this.windowSize;
                const freq1 = this.buildFrequencyMap(atoms);
                let total = 0;
                const limit = Math.min(this.windowSize, this.history.length);
                for (let i = 0; i < limit; i++) {
                    const other = this.history[this.history.length - 1 - i];
                    const freq2 = other.frequency;
                    const allKeys = new Set([...freq1.keys(), ...freq2.keys()]);
                    let diff = 0;
                    allKeys.forEach(key => {
                        diff += Math.abs((freq1.get(key) || 0) - (freq2.get(key) || 0));
                    });
                    total += diff;
                }
                return total / limit;
            }

            buildFrequencyMap(atoms) {
                const freq = new Map();
                atoms.forEach(key => {
                    freq.set(key, (freq.get(key) || 0) + 1);
                });
                return freq;
            }

            evaluate(premise, signatures, trialIndex) {
                const exactHit = this.seenExact.has(signatures.exact);
                if (exactHit) {
                    return {
                        blocked: true,
                        reason: 'exact-repeat',
                        penalty: Infinity,
                        noveltyScores: { exact: 1, mirror: 0, iso: 0, hamming: 0 }
                    };
                }

                const mirrorHit = this.seenMirror.has(signatures.mirror);
                const isoHit = this.seenIso.has(signatures.iso);
                const hamming = this.computeHamming(signatures.atoms);

                const noveltyScores = {
                    exact: mirrorHit ? 1 : 0,
                    mirror: mirrorHit ? 1 : 0,
                    iso: isoHit ? 1 : 0,
                    hamming
                };

                if (trialIndex < this.firstN && (mirrorHit || isoHit)) {
                    return {
                        blocked: true,
                        reason: 'novelty-mode',
                        penalty: Infinity,
                        noveltyScores
                    };
                }

                let penalty = 0;
                if (mirrorHit) penalty += 1;
                if (isoHit) penalty += 2;

                return {
                    blocked: false,
                    penalty,
                    noveltyScores
                };
            }

            register(signatures) {
                this.seenExact.add(signatures.exact);
                this.seenMirror.add(signatures.mirror);
                this.seenIso.add(signatures.iso);
                this.history.push({
                    signature: signatures.exact,
                    frequency: this.buildFrequencyMap(signatures.atoms)
                });
                if (this.history.length > this.windowSize) {
                    this.history.shift();
                }
            }

            reset() {
                this.seenExact.clear();
                this.seenMirror.clear();
                this.seenIso.clear();
                this.history = [];
            }
        }

        class LetterPoolManager {
            constructor(allLetters, rng, usageTracker) {
                this.allLetters = allLetters;
                this.rng = rng;
                this.usageTracker = usageTracker;
                this.currentPool = [];
            }

            getUsage(letter) {
                const usage = this.usageTracker.get(letter);
                if (!usage) return 0;
                return usage.head + usage.tail;
            }

            sampleLetters(count, candidates = this.allLetters) {
                const available = candidates.filter(l => !this.currentPool.includes(l));
                const selection = [];
                const pool = [...available];
                while (selection.length < count && pool.length > 0) {
                    const weights = pool.map(letter => 1 / (1 + this.getUsage(letter)));
                    const choice = this.rng.weightedChoice(pool, weights);
                    selection.push(choice);
                    const index = pool.indexOf(choice);
                    pool.splice(index, 1);
                }
                return selection;
            }

            nextPool(k, options = {}) {
                const { expand = false } = options;
                const min = k + 1;
                const max = Math.min(6, 2 * k + 2);
                const targetSize = Math.max(min, Math.min(max, (this.currentPool.length || min) + (expand ? 1 : 0)));

                if (this.currentPool.length === 0) {
                    const letters = this.rng.shuffle(this.allLetters).slice(0, targetSize);
                    this.currentPool = letters;
                    return this.currentPool;
                }

                const drift = expand ? 0.5 : this.rng.nextBetween(0.3, 0.5);
                const keepCount = Math.max(min, Math.round(targetSize * (1 - drift)));
                const orderedByUsage = [...this.currentPool].sort((a, b) => this.getUsage(a) - this.getUsage(b));
                const keep = orderedByUsage.slice(0, keepCount);
                const needed = targetSize - keep.length;
                const candidates = this.allLetters.filter(letter => !keep.includes(letter));
                const additions = this.sampleLetters(needed, candidates);
                this.currentPool = this.rng.shuffle([...keep, ...additions]);
                return this.currentPool;
            }
        }

        function collectLetters(atoms) {
            const set = new Set();
            atoms.forEach(atom => {
                set.add(atom.head);
                set.add(atom.tail);
            });
            return set;
        }

        function addEdge(map, from, to) {
            if (!map.has(from)) {
                map.set(from, new Set());
            }
            map.get(from).add(to);
        }

        function topologicalAssign(nodes, edges) {
            const indegree = new Map();
            nodes.forEach(node => indegree.set(node, 0));
            edges.forEach((targets, source) => {
                targets.forEach(target => {
                    indegree.set(target, (indegree.get(target) || 0) + 1);
                });
            });

            const queue = [];
            indegree.forEach((degree, node) => {
                if (degree === 0) queue.push(node);
            });

            const order = [];
            while (queue.length > 0) {
                const node = queue.shift();
                order.push(node);
                const neighbors = edges.get(node);
                if (!neighbors) continue;
                neighbors.forEach(neighbor => {
                    indegree.set(neighbor, indegree.get(neighbor) - 1);
                    if (indegree.get(neighbor) === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            if (order.length !== nodes.length) {
                return { cycle: true, values: new Map() };
            }

            const values = new Map();
            order.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
                const base = values.get(node);
                const neighbors = edges.get(node);
                if (!neighbors) return;
                neighbors.forEach(neighbor => {
                    const current = values.get(neighbor) || 0;
                    const candidate = Math.max(current, base + 1);
                    values.set(neighbor, candidate);
                });
            });

            nodes.forEach(node => {
                if (!values.has(node)) values.set(node, 0);
            });

            return { cycle: false, values };
        }

        function buildReachability(nodes, edges) {
            const reach = new Map();
            nodes.forEach(node => {
                const visited = new Set();
                const stack = [node];
                while (stack.length) {
                    const current = stack.pop();
                    const neighbors = edges.get(current);
                    if (!neighbors) continue;
                    neighbors.forEach(next => {
                        if (!visited.has(next)) {
                            visited.add(next);
                            stack.push(next);
                        }
                    });
                }
                reach.set(node, visited);
            });
            return reach;
        }

        class ConstraintSolver {
            analyze(allAtoms) {
                const letters = collectLetters(allAtoms);
                const ufX = new DisjointSet(letters);
                const ufY = new DisjointSet(letters);

                const graphX = new Map();
                const graphY = new Map();

                for (const atom of allAtoms) {
                    if (atom.axis === 'N' || atom.axis === 'S') {
                        ufX.union(atom.head, atom.tail);
                    } else {
                        ufY.union(atom.head, atom.tail);
                    }
                }

                for (const atom of allAtoms) {
                    if (atom.axis === 'N') {
                        const lesser = ufY.find(atom.tail);
                        const greater = ufY.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'S') {
                        const lesser = ufY.find(atom.head);
                        const greater = ufY.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'vertical-collision' };
                        }
                        addEdge(graphY, lesser, greater);
                    } else if (atom.axis === 'E') {
                        const lesser = ufX.find(atom.tail);
                        const greater = ufX.find(atom.head);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    } else if (atom.axis === 'W') {
                        const lesser = ufX.find(atom.head);
                        const greater = ufX.find(atom.tail);
                        if (lesser === greater) {
                            return { ok: false, reason: 'horizontal-collision' };
                        }
                        addEdge(graphX, lesser, greater);
                    }
                }

                const nodesX = Array.from(new Set([...graphX.keys(), ...Array.from(graphX.values()).flat()]));
                ufX.parent.forEach((_, letter) => nodesX.push(ufX.find(letter)));
                const uniqueNodesX = Array.from(new Set(nodesX));

                const nodesY = Array.from(new Set([...graphY.keys(), ...Array.from(graphY.values()).flat()]));
                ufY.parent.forEach((_, letter) => nodesY.push(ufY.find(letter)));
                const uniqueNodesY = Array.from(new Set(nodesY));

                const assignX = topologicalAssign(uniqueNodesX, graphX);
                if (assignX.cycle) {
                    return { ok: false, reason: 'horizontal-cycle' };
                }

                const assignY = topologicalAssign(uniqueNodesY, graphY);
                if (assignY.cycle) {
                    return { ok: false, reason: 'vertical-cycle' };
                }

                const coordinates = new Map();
                letters.forEach(letter => {
                    const xRep = ufX.find(letter);
                    const yRep = ufY.find(letter);
                    const x = assignX.values.get(xRep) || 0;
                    const y = assignY.values.get(yRep) || 0;
                    coordinates.set(letter, { x, y });
                });

                return {
                    ok: true,
                    coordinates,
                    ufX,
                    ufY,
                    graphX,
                    graphY,
                    nodesX: uniqueNodesX,
                    nodesY: uniqueNodesY
                };
            }

            evaluate(windowAtoms, candidateAtoms) {
                return this.analyze([...windowAtoms, ...candidateAtoms]);
            }
        }

        class EquivalenceEngine {
            constructor(transitivityEnabled = false) {
                this.transitivityEnabled = transitivityEnabled;
            }

            setTransitivity(enabled) {
                this.transitivityEnabled = enabled;
            }

            computeCertificate(nBackPremise, candidatePremise, midAtoms) {
                if (!nBackPremise) {
                    return { match: false, reason: 'no-nback' };
                }

                if (nBackPremise.toKey() === candidatePremise.toKey()) {
                    return { match: false, reason: 'identity' };
                }

                const atomsA = nBackPremise.atoms;
                const atomsB = candidatePremise.atoms;
                if (atomsA.length !== atomsB.length) {
                    return { match: false, reason: 'arity-mismatch' };
                }

                const lettersA = Array.from(nBackPremise.getLetters()).sort();
                const lettersB = Array.from(candidatePremise.getLetters()).sort();
                if (lettersA.length !== lettersB.length) {
                    return { match: false, reason: 'letter-cardinality' };
                }

                for (let i = 0; i < lettersA.length; i++) {
                    if (lettersA[i] !== lettersB[i]) {
                        return { match: false, reason: 'letter-parity' };
                    }
                }

                const sharedLetters = lettersA.filter(letter => lettersB.includes(letter));
                if (sharedLetters.length < 2) {
                    return { match: false, reason: 'anchor-failure' };
                }

                const mapping = [];
                const used = new Set();

                const search = (index) => {
                    if (index === atomsA.length) return true;
                    for (let j = 0; j < atomsB.length; j++) {
                        if (used.has(j)) continue;
                        if (atomsA[index].equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: false });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                        const inverted = Atom.invert(atomsA[index]);
                        if (inverted.equals(atomsB[j])) {
                            used.add(j);
                            mapping.push({ from: atomsA[index].toKey(), to: atomsB[j].toKey(), inverted: true });
                            if (search(index + 1)) return true;
                            mapping.pop();
                            used.delete(j);
                        }
                    }
                    return false;
                };

                const isInvertible = search(0);
                if (!isInvertible) {
                    return { match: false, reason: 'no-invertible-mapping' };
                }

                const midAnalysis = midAtoms.length > 0 ? new ConstraintSolver().analyze(midAtoms) : { ok: true, ufX: new DisjointSet(), ufY: new DisjointSet(), graphX: new Map(), graphY: new Map(), nodesX: [], nodesY: [] };
                let midDerivable = false;

                if (midAnalysis.ok) {
                    const reachX = buildReachability(midAnalysis.nodesX, midAnalysis.graphX);
                    const reachY = buildReachability(midAnalysis.nodesY, midAnalysis.graphY);

                    const checkDerivable = (atom) => {
                        if (atom.axis === 'N') {
                            const lesser = midAnalysis.ufY.find(atom.tail);
                            const greater = midAnalysis.ufY.find(atom.head);
                            const reach = reachY.get(lesser);
                            return reach ? reach.has(greater) : false;
                        }
                        if (atom.axis === 'S') {
                            const lesser = midAnalysis.ufY.find(atom.head);
                            const greater = midAnalysis.ufY.find(atom.tail);
                            const reach = reachY.get(lesser);
                            return reach ? reach.has(greater) : false;
                        }
                        if (atom.axis === 'E') {
                            const lesser = midAnalysis.ufX.find(atom.tail);
                            const greater = midAnalysis.ufX.find(atom.head);
                            const reach = reachX.get(lesser);
                            return reach ? reach.has(greater) : false;
                        }
                        if (atom.axis === 'W') {
                            const lesser = midAnalysis.ufX.find(atom.head);
                            const greater = midAnalysis.ufX.find(atom.tail);
                            const reach = reachX.get(lesser);
                            return reach ? reach.has(greater) : false;
                        }
                        return false;
                    };

                    for (const atom of atomsA) {
                        if (checkDerivable(atom) || checkDerivable(Atom.invert(atom))) {
                            midDerivable = true;
                            break;
                        }
                    }
                }

                if (midDerivable && !this.transitivityEnabled) {
                    return { match: false, reason: 'mid-derivable', midWindowDerivable: true };
                }

                const certificate = {
                    type: 'invertible',
                    mapping,
                    sharedLetters,
                    parity: true,
                    midWindowDerivable: midDerivable
                };

                return { match: true, certificate, midWindowDerivable: midDerivable };
            }
        }

        class MatchPlanner {
            constructor(rng) {
                this.rng = rng;
                this.schedule = [];
                this.flips = new Map();
            }

            plan(totalTrials, n) {
                this.schedule = new Array(totalTrials).fill(false);
                this.flips.clear();
                const rate = this.rng.nextBetween(0.35, 0.55);
                const history = [];
                for (let i = 0; i < totalTrials; i++) {
                    if (i < n) {
                        this.schedule[i] = false;
                        history.push(false);
                        continue;
                    }

                    let decision = this.rng.next() < rate;
                    if (this.wouldRepeat(history, decision)) {
                        decision = !decision;
                        this.flips.set(i, true);
                    }

                    this.schedule[i] = decision;
                    history.push(decision);
                    if (history.length > 24) history.shift();
                }
                return this.schedule;
            }

            wouldRepeat(history, decision) {
                const window = [...history, decision];
                if (window.length < 24) return false;
                const recent = window.slice(-12);
                const previous = window.slice(-24, -12);
                return this.isRotationEqual(previous, recent);
            }

            isRotationEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) return false;
                const joined1 = arr1.join('');
                const joined2 = arr2.join('');
                return (joined1 + joined1).includes(joined2);
            }

            forceFlip(index) {
                if (index < 0 || index >= this.schedule.length) return;
                this.schedule[index] = !this.schedule[index];
                this.flips.set(index, true);
            }

            wasFlipped(index) {
                return this.flips.get(index) || false;
            }
        }

        class GameLogger {
            constructor() {
                this.entries = [];
            }

            add(entry) {
                this.entries.push(entry);
            }

            reset() {
                this.entries = [];
            }

            toCSV() {
                if (this.entries.length === 0) return '';
                const headers = Object.keys(this.entries[0]);
                const rows = [headers.join(',')];
                this.entries.forEach(entry => {
                    const row = headers.map(key => {
                        const value = entry[key];
                        if (value === null || value === undefined) return '';
                        if (typeof value === 'object') {
                            return JSON.stringify(value).replace(/"/g, '""');
                        }
                        return String(value).replace(/"/g, '""');
                    }).join(',');
                    rows.push(row);
                });
                return rows.join('\n');
            }

            toJSON() {
                return JSON.stringify(this.entries, null, 2);
            }
        }

        class GameState {
            constructor(seed, options) {
                this.seed = seed;
                this.rng = new Mulberry32(seed);
                this.letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                this.windowSize = options.windowSize;
                this.currentStep = 0;
                this.constraintStore = [];
                this.premiseHistory = [];
                this.letterUsage = new Map();
                this.axisUsage = { N: 0, S: 0, E: 0, W: 0 };
                this.cooldown = new Map();
                this.novelty = new NoveltyManager(HAMMING_WINDOW, FIRST_N_NOVELTY);
                this.letterPool = new LetterPoolManager(this.letters, this.rng, this.letterUsage);
                this.coordinates = new Map();
            }

            resetNovelty() {
                this.novelty.reset();
            }

            getWindowAtoms() {
                const cutoff = Math.max(0, this.currentStep - this.windowSize);
                return this.constraintStore
                    .filter(entry => entry.step >= cutoff)
                    .flatMap(entry => entry.atoms);
            }

            getConstraintsInRange(start, end) {
                return this.constraintStore
                    .filter(entry => entry.step >= start && entry.step <= end)
                    .flatMap(entry => entry.atoms);
            }

            ensureLetterUsage(letter) {
                if (!this.letterUsage.has(letter)) {
                    this.letterUsage.set(letter, { head: 0, tail: 0 });
                }
                return this.letterUsage.get(letter);
            }

            updateUsage(premise) {
                premise.atoms.forEach(atom => {
                    this.ensureLetterUsage(atom.head).head += 1;
                    this.ensureLetterUsage(atom.tail).tail += 1;
                    this.axisUsage[atom.axis] += 1;
                });
            }

            recordPremise(premise, atoms, metadata) {
                this.constraintStore.push({ step: this.currentStep, atoms });
                this.premiseHistory.push({ step: this.currentStep, premise, metadata });
                this.currentStep += 1;

                const cutoff = this.currentStep - this.windowSize;
                this.constraintStore = this.constraintStore.filter(entry => entry.step >= cutoff);
                this.premiseHistory = this.premiseHistory.filter(entry => entry.step >= cutoff - this.windowSize);

                this.updateUsage(premise);
            }

            getPremiseAt(index) {
                const entry = this.premiseHistory.find(p => p.step === index);
                return entry ? entry.premise : null;
            }

            getActiveCooldown(currentTrial) {
                const active = new Set();
                this.cooldown.forEach((expiry, letter) => {
                    if (expiry > currentTrial) {
                        active.add(letter);
                    }
                });
                return active;
            }

            applyCooldown(letters, currentTrial, n) {
                const cooldownLength = Math.ceil(n / 2);
                letters.forEach(letter => {
                    this.cooldown.set(letter, currentTrial + cooldownLength);
                });
            }
        }

        class PremiseGenerator {
            constructor(state, solver, equivalence) {
                this.state = state;
                this.solver = solver;
                this.equivalence = equivalence;
            }

            generate(options) {
                const {
                    trialIndex,
                    k,
                    n,
                    plannedMatch,
                    nBackPremise,
                    middleAtoms,
                    avoidLetters,
                    allowOverride
                } = options;

                const windowAtoms = this.state.getWindowAtoms();
                let bestCandidate = null;
                let attempts = 0;
                let expanded = false;

                while (attempts < MAX_GENERATION_ATTEMPTS) {
                    const expand = attempts > 0 && attempts % NOVELTY_OVERRIDE_THRESHOLD === 0;
                    if (expand) expanded = true;
                    const pool = this.state.letterPool.nextPool(k, { expand });
                    const candidateAtoms = plannedMatch
                        ? this.buildMatchCandidate(nBackPremise, pool, k)
                        : this.buildNovelPremise(pool, k, avoidLetters);
                    attempts++;
                    if (!candidateAtoms) continue;

                    const premise = new Premise(candidateAtoms);
                    const signatures = this.state.novelty.buildSignatures(premise);
                    const novelty = this.state.novelty.evaluate(premise, signatures, trialIndex);

                    if (novelty.blocked && !(allowOverride && expanded)) {
                        continue;
                    }

                    const satResult = this.solver.evaluate(windowAtoms, premise.atoms);
                    if (!satResult.ok) {
                        continue;
                    }

                    let certificate = null;
                    let midDerivable = false;

                    if (plannedMatch) {
                        const equivalence = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms);
                        if (!equivalence.match) {
                            continue;
                        }
                        certificate = equivalence.certificate;
                        midDerivable = equivalence.midWindowDerivable;
                    } else {
                        if (nBackPremise) {
                            const check = this.equivalence.computeCertificate(nBackPremise, premise, middleAtoms);
                            if (check.match) {
                                continue;
                            }
                        }
                    }

                    const score = Math.exp(ACCEPTANCE_ALPHA * novelty.noveltyScores.hamming - ACCEPTANCE_BETA * novelty.penalty);
                    if (!bestCandidate || score > bestCandidate.score) {
                        bestCandidate = {
                            premise,
                            signatures,
                            novelty,
                            satResult,
                            certificate,
                            midDerivable,
                            attempts
                        };
                    }

                    if (this.state.rng.next() < Math.min(1, score)) {
                        return bestCandidate;
                    }
                }

                return bestCandidate;
            }

            buildMatchCandidate(nBackPremise, pool, k) {
                if (!nBackPremise) return null;
                const atoms = [];
                const nAtoms = nBackPremise.atoms;
                for (let i = 0; i < nAtoms.length; i++) {
                    const atom = nAtoms[i];
                    const invert = this.state.rng.next() < 0.6;
                    atoms.push(invert ? Atom.invert(atom) : new Atom(atom.axis, atom.head, atom.tail));
                }

                while (atoms.length < k) {
                    const head = this.state.rng.choice(pool);
                    const tailOptions = pool.filter(l => l !== head);
                    if (tailOptions.length === 0) break;
                    const tail = this.state.rng.choice(tailOptions);
                    const axis = this.state.rng.choice(MATCH_AXES);
                    atoms.push(new Atom(axis, head, tail));
                }
                return atoms.slice(0, k);
            }

            buildNovelPremise(pool, k, avoidLetters) {
                const atoms = [];
                const usedPairs = new Set();
                const axisWeights = MATCH_AXES.map(axis => 1 / (1 + this.state.axisUsage[axis]));

                for (let i = 0; i < k; i++) {
                    let attempts = 0;
                    while (attempts < 40) {
                        let head = this.state.rng.choice(pool);
                        let tailCandidates = pool.filter(letter => letter !== head);
                        if (avoidLetters && avoidLetters.size > 0) {
                            const filtered = tailCandidates.filter(letter => !avoidLetters.has(letter));
                            if (filtered.length > 0) {
                                tailCandidates = filtered;
                            }
                            if (avoidLetters.has(head)) {
                                const alternatives = pool.filter(letter => !avoidLetters.has(letter));
                                if (alternatives.length > 0) {
                                    head = this.state.rng.choice(alternatives);
                                    tailCandidates = pool.filter(letter => letter !== head && !avoidLetters.has(letter));
                                }
                            }
                        }

                        if (tailCandidates.length === 0) break;
                        const tail = this.state.rng.choice(tailCandidates);
                        const pairKey = `${head}|${tail}`;
                        if (usedPairs.has(pairKey)) {
                            attempts++;
                            continue;
                        }

                        const axis = this.state.rng.weightedChoice(MATCH_AXES, axisWeights);
                        atoms.push(new Atom(axis, head, tail));
                        usedPairs.add(pairKey);
                        break;
                    }
                }

                return atoms.length === k ? atoms : null;
            }
        }

        class VoiceSynthesis {
            constructor() {
                this.synth = window.speechSynthesis;
                this.voice = null;
                this.voiceReady = false;
                this.pitch = 1.2;
                this.rate = 0.9;
                this.volume = 1.0;
                this.queue = [];
                this.isSpeaking = false;
                this.sessionToken = 0;
            }

            async initialize() {
                await new Promise(resolve => {
                    const attempt = () => {
                        const voices = this.synth.getVoices();
                        if (voices.length === 0) {
                            setTimeout(attempt, 200);
                            return;
                        }
                        this.selectVoice(voices);
                        this.voiceReady = true;
                        resolve();
                    };
                    attempt();
                });
            }

            selectVoice(voices) {
                const storedName = localStorage.getItem('relational-nback-voice-name');
                const storedLang = localStorage.getItem('relational-nback-voice-lang');

                if (storedName && storedLang) {
                    const stored = voices.find(v => v.name === storedName && v.lang === storedLang);
                    if (stored) {
                        this.voice = stored;
                        return;
                    }
                }

                const preferredLocales = ['en-AU', 'en-GB', 'en-US'];
                const feminineHints = ['Female', 'Karen', 'Natasha', 'Sonia', 'Serena', 'Aria', 'Samantha'];

                for (const locale of preferredLocales) {
                    const candidates = voices.filter(v => v.lang.startsWith(locale));
                    for (const hint of feminineHints) {
                        const match = candidates.find(v => v.name.includes(hint));
                        if (match) {
                            this.voice = match;
                            localStorage.setItem('relational-nback-voice-name', match.name);
                            localStorage.setItem('relational-nback-voice-lang', match.lang);
                            return;
                        }
                    }
                    if (candidates.length) {
                        this.voice = candidates[0];
                        return;
                    }
                }

                this.voice = voices[0] || null;
            }

            getVoiceInfo() {
                return this.voice ? `${this.voice.name} (${this.voice.lang})` : 'Voice not initialized';
            }

            speak(text, sessionToken) {
                return new Promise(resolve => {
                    this.queue.push({ text, resolve, sessionToken });
                    this.processQueue();
                });
            }

            async processQueue() {
                if (this.isSpeaking) return;
                const item = this.queue.shift();
                if (!item) return;

                this.isSpeaking = true;
                const utterance = new SpeechSynthesisUtterance(item.text);
                utterance.voice = this.voice;
                utterance.pitch = this.pitch;
                utterance.rate = this.rate;
                utterance.volume = this.volume;

                utterance.onend = () => {
                    this.isSpeaking = false;
                    item.resolve();
                    this.processQueue();
                };

                this.synth.speak(utterance);
            }

            async speakPremise(premise, sessionToken) {
                if (!premise) return;
                const text = premise.toNaturalSpeech();
                return this.speak(text, sessionToken);
            }

            async cancelAndWait() {
                this.synth.cancel();
                this.isSpeaking = false;
                await new Promise(resolve => setTimeout(resolve, 50));
            }
        }

        class GameEngine {
            constructor() {
                this.seedManager = new SeedManager();
                this.logger = new GameLogger();
                this.voice = new VoiceSynthesis();
                this.secondsPerTrial = 6;
                this.n = 2;
                this.k = 1;
                this.totalTrials = 60;
                this.state = null;
                this.solver = null;
                this.equivalence = new EquivalenceEngine(false);
                this.generator = null;
                this.planner = null;
                this.matchSchedule = [];
                this.trialIndex = 0;
                this.awaitingResponse = false;
                this.sessionToken = 0;
                this.responseResolver = null;
                this.responseTimer = null;
                this.responseStartTime = 0;
                this.currentPremises = [];
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.M = 8;
                this.gameRunning = false;
                this.lockSeed = this.seedManager.getLockPreference();
                this.resetOnRestart = false;
                this.pendingPlannerFlip = false;
            }

            async initialize() {
                await this.voice.initialize();
                this.updateVoiceInfo();
                this.attachUI();
                this.updateUI();
            }

            attachUI() {
                document.getElementById('lock-seed-toggle').checked = this.lockSeed;
                document.getElementById('lock-seed-toggle').addEventListener('change', (e) => {
                    this.lockSeed = e.target.checked;
                    this.seedManager.setLockPreference(this.lockSeed);
                });

                document.getElementById('reset-seed-toggle').addEventListener('change', (e) => {
                    this.resetOnRestart = e.target.checked;
                });

                document.getElementById('transitivity-toggle').addEventListener('change', (e) => {
                    this.equivalence.setTransitivity(e.target.checked);
                });

                document.getElementById('debug-toggle').addEventListener('change', (e) => {
                    document.getElementById('debug').hidden = !e.target.checked;
                });

                const sptSlider = document.getElementById('spt-slider');
                const sptNumber = document.getElementById('spt-number');
                const syncSeconds = (value) => {
                    this.secondsPerTrial = parseFloat(value);
                    document.getElementById('spt-value').textContent = this.secondsPerTrial.toFixed(1);
                };
                sptSlider.addEventListener('input', (e) => {
                    sptNumber.value = e.target.value;
                    syncSeconds(e.target.value);
                });
                sptNumber.addEventListener('input', (e) => {
                    sptSlider.value = e.target.value;
                    syncSeconds(e.target.value);
                });

                document.getElementById('n-slider').addEventListener('input', (e) => {
                    this.n = parseInt(e.target.value, 10);
                    document.getElementById('n-value').textContent = this.n;
                });

                document.getElementById('k-slider').addEventListener('input', (e) => {
                    this.k = parseInt(e.target.value, 10);
                    document.getElementById('k-value').textContent = this.k;
                });

                document.getElementById('start-btn').addEventListener('click', () => this.start(true));
                document.getElementById('restart-btn').addEventListener('click', () => this.start(false));
                document.getElementById('stop-btn').addEventListener('click', () => this.stop());
                document.getElementById('match-btn').addEventListener('click', () => this.handleResponse(true));
                document.getElementById('no-match-btn').addEventListener('click', () => this.handleResponse(false));
                document.getElementById('repeat-btn').addEventListener('click', () => this.handleRepeat());

                document.getElementById('preview-btn').addEventListener('click', async () => {
                    const previewPremise = new Premise([
                        new Atom('N', 'A', 'B'),
                        new Atom('E', 'C', 'D')
                    ]);
                    await this.voice.speakPremise(previewPremise, 0);
                });

                document.addEventListener('keydown', (e) => {
                    if (!this.awaitingResponse) return;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.handleResponse(true);
                    } else if (e.code === 'Enter') {
                        e.preventDefault();
                        this.handleResponse(false);
                    }
                });

                document.getElementById('export-btn').addEventListener('click', () => {
                    this.exportData();
                });

                document.getElementById('test-btn').addEventListener('click', async () => {
                    const panel = document.getElementById('test-panel');
                    const resultsEl = document.getElementById('test-results');
                    panel.hidden = false;
                    resultsEl.innerHTML = '<p>Running tests...</p>';
                    const harness = new TestHarness();
                    const results = await harness.runAll();
                    resultsEl.innerHTML = results.map(result => {
                        const cls = result.passed ? 'pass' : 'fail';
                        const symbol = result.passed ? 'âœ“' : 'âœ—';
                        return `<div class="test-result ${cls}">${symbol} ${result.test}: ${result.details}</div>`;
                    }).join('');
                });
            }

            updateVoiceInfo() {
                document.getElementById('voice-info').innerHTML = `<strong>Voice:</strong> ${this.voice.getVoiceInfo()}`;
            }

            updateUI() {
                document.getElementById('trial-count').textContent = this.trialIndex;
                document.getElementById('score').textContent = this.score;
                document.getElementById('omissions').textContent = this.omissions;
                const accuracy = this.totalResponses > 0 ? (this.correctResponses / this.totalResponses) * 100 : null;
                document.getElementById('accuracy').textContent = accuracy !== null ? `${accuracy.toFixed(1)}%` : '-';
                const rolling = this.recentAccuracy.length > 0
                    ? (this.recentAccuracy.reduce((a, b) => a + b, 0) / this.recentAccuracy.length) * 100
                    : null;
                document.getElementById('rolling-acc').textContent = rolling !== null ? `${rolling.toFixed(1)}%` : '-';

                document.getElementById('status').textContent = this.gameRunning
                    ? `Running (n=${this.n}, k=${this.k})`
                    : 'Idle';

                document.getElementById('start-btn').disabled = this.gameRunning;
                document.getElementById('restart-btn').disabled = !this.gameRunning;
                document.getElementById('stop-btn').disabled = !this.gameRunning;
            }

            async start(isFreshStart) {
                if (this.gameRunning) return;
                this.gameRunning = true;
                this.trialIndex = 0;
                this.score = 0;
                this.correctResponses = 0;
                this.totalResponses = 0;
                this.omissions = 0;
                this.recentAccuracy = [];
                this.pendingPlannerFlip = false;

                const seed = this.seedManager.generateSessionSeed(this.lockSeed);
                this.state = new GameState(seed, { windowSize: Math.max(2 * this.n + 2, 12) });
                this.state.resetNovelty();
                this.solver = new ConstraintSolver();
                this.generator = new PremiseGenerator(this.state, this.solver, this.equivalence);
                this.planner = new MatchPlanner(this.state.rng);
                this.matchSchedule = this.planner.plan(this.totalTrials, this.n);
                if (isFreshStart || this.resetOnRestart) {
                    this.logger.reset();
                }
                this.currentPremises = [];

                this.updateUI();
                this.sessionToken += 1;
                const currentSession = this.sessionToken;

                while (this.trialIndex < this.totalTrials && this.gameRunning && currentSession === this.sessionToken) {
                    await this.runTrial(currentSession);
                    this.trialIndex += 1;
                    this.updateUI();
                }

                if (currentSession === this.sessionToken) {
                    this.stop();
                }
            }

            stop() {
                this.gameRunning = false;
                this.awaitingResponse = false;
                if (this.responseTimer) {
                    clearTimeout(this.responseTimer);
                    this.responseTimer = null;
                }
                if (this.responseResolver) {
                    this.responseResolver(null);
                    this.responseResolver = null;
                }
                document.getElementById('match-btn').disabled = true;
                document.getElementById('no-match-btn').disabled = true;
                document.getElementById('repeat-btn').disabled = true;
                this.updateUI();
            }

            async runTrial(sessionToken) {
                if (!this.gameRunning) return;

                const plannedMatch = this.matchSchedule[this.trialIndex] || false;
                const nBackIndex = this.trialIndex - this.n;
                const nBackPremise = nBackIndex >= 0 ? this.currentPremises[nBackIndex] : null;
                const middleAtoms = nBackIndex >= 0 ? this.state.getConstraintsInRange(nBackIndex + 1, this.trialIndex - 1) : [];
                const cooldown = this.state.getActiveCooldown(this.trialIndex);

                let result = this.generator.generate({
                    trialIndex: this.trialIndex,
                    k: this.k,
                    n: this.n,
                    plannedMatch,
                    nBackPremise,
                    middleAtoms,
                    avoidLetters: plannedMatch ? cooldown : null,
                    allowOverride: true
                });

                let plannerFlip = false;

                if (!result && plannedMatch) {
                    this.planner.forceFlip(this.trialIndex);
                    plannerFlip = true;
                    result = this.generator.generate({
                        trialIndex: this.trialIndex,
                        k: this.k,
                        n: this.n,
                        plannedMatch: false,
                        nBackPremise,
                        middleAtoms,
                        avoidLetters: null,
                        allowOverride: true
                    });
                }

                if (!result) {
                    this.stop();
                    return;
                }

                const { premise, signatures, novelty, satResult, certificate } = result;
                this.currentPremises.push(premise);
                this.state.recordPremise(premise, premise.atoms, { plannedMatch, certificate });
                this.state.novelty.register(signatures);
                this.state.coordinates = satResult.coordinates;

                document.getElementById('premise-display').textContent = premise.toString();
                await this.voice.speakPremise(premise, sessionToken);
                if (sessionToken !== this.sessionToken) return;

                this.awaitingResponse = true;
                this.responseStartTime = Date.now();

                const response = await new Promise(resolve => {
                    this.responseResolver = resolve;
                    document.getElementById('match-btn').disabled = false;
                    document.getElementById('no-match-btn').disabled = false;
                    document.getElementById('repeat-btn').disabled = false;
                    this.responseTimer = setTimeout(() => {
                        if (this.responseResolver) {
                            this.responseResolver(null);
                            this.responseResolver = null;
                        }
                    }, this.secondsPerTrial * 1000);
                });

                if (sessionToken !== this.sessionToken) return;

                this.awaitingResponse = false;
                if (this.responseTimer) {
                    clearTimeout(this.responseTimer);
                    this.responseTimer = null;
                }
                document.getElementById('match-btn').disabled = true;
                document.getElementById('no-match-btn').disabled = true;
                document.getElementById('repeat-btn').disabled = true;

                const certificateMatch = plannedMatch && certificate;
                const actualMatch = Boolean(certificateMatch);
                let correct = false;
                let omission = false;

                if (response === null) {
                    omission = true;
                    this.omissions += 1;
                } else {
                    correct = response === actualMatch;
                    if (correct) {
                        this.score += 1;
                        this.correctResponses += 1;
                    }
                    this.totalResponses += 1;
                    this.recentAccuracy.push(correct ? 1 : 0);
                    if (this.recentAccuracy.length > this.M) {
                        this.recentAccuracy.shift();
                    }
                }

                const rt = response === null ? null : Date.now() - this.responseStartTime;
                const feedbackEl = document.getElementById('feedback');
                if (omission) {
                    feedbackEl.textContent = 'Response window expired.';
                    feedbackEl.className = 'feedback incorrect';
                } else if (correct) {
                    feedbackEl.textContent = 'Correct';
                    feedbackEl.className = 'feedback correct';
                } else {
                    feedbackEl.textContent = 'Incorrect';
                    feedbackEl.className = 'feedback incorrect';
                }

                if (actualMatch && certificate) {
                    this.state.applyCooldown(Array.from(premise.getLetters()), this.trialIndex, this.n);
                }

                const logEntry = {
                    seedSession: this.seedManager.sessionSeed,
                    trialIndex: this.trialIndex,
                    n: this.n,
                    k: this.k,
                    letters: Array.from(premise.getLetters()).join(''),
                    atomsCanonical: premise.toKey(),
                    atomsMirrorCanonical: premise.mirrorKey(),
                    isoSignature: premise.isoSignature(),
                    plannedMatch,
                    certificate: certificate || null,
                    satStatus: satResult.ok,
                    midWindowDerivable: certificate ? certificate.midWindowDerivable : false,
                    noveltyScores: novelty.noveltyScores,
                    response: { choice: response, correct, rtMs: rt, omission },
                    cooldownLetters: Array.from(this.state.getActiveCooldown(this.trialIndex + 1)),
                    plannerFlip: plannerFlip || this.planner.wasFlipped(this.trialIndex)
                };

                this.logger.add(logEntry);
                this.updateDebugPanel(logEntry);
            }

            updateDebugPanel(entry) {
                const debug = document.getElementById('debug-content');
                const el = document.createElement('div');
                el.className = 'debug-premise';
                el.textContent = `Trial ${entry.trialIndex}: ${entry.atomsCanonical} | Match=${entry.plannedMatch} | Response=${entry.response.choice}`;
                debug.prepend(el);
                while (debug.childElementCount > 20) {
                    debug.removeChild(debug.lastChild);
                }
            }

            handleResponse(isMatch) {
                if (!this.awaitingResponse || !this.responseResolver) return;
                if (this.responseTimer) {
                    clearTimeout(this.responseTimer);
                    this.responseTimer = null;
                }
                this.responseResolver(isMatch);
                this.responseResolver = null;
            }

            async handleRepeat() {
                if (!this.awaitingResponse) return;
                if (this.responseTimer) {
                    clearTimeout(this.responseTimer);
                    this.responseTimer = null;
                }
                await this.voice.cancelAndWait();
                await this.voice.speakPremise(this.currentPremises[this.trialIndex], this.sessionToken);
                if (!this.awaitingResponse) return;
                this.responseStartTime = Date.now();
                this.responseTimer = setTimeout(() => {
                    if (this.responseResolver) {
                        this.responseResolver(null);
                        this.responseResolver = null;
                    }
                }, this.secondsPerTrial * 1000);
            }

            exportData() {
                const data = {
                    seedSession: this.seedManager.sessionSeed,
                    entries: this.logger.entries
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `imagi-world-session-${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        class TestHarness {
            constructor() {
                this.seedManager = new SeedManager();
            }

            async runAll() {
                return [
                    await this.testNovelty(),
                    await this.testContradictions(),
                    await this.testCertificate(),
                    await this.testInputGating(),
                    await this.testProofExamples()
                ];
            }

            async testNovelty() {
                const seeds = [];
                const firstPremises = new Set();
                for (let i = 0; i < 5; i++) {
                    const seed = this.seedManager.generateSessionSeed(false);
                    seeds.push(seed);
                    const state = new GameState(seed, { windowSize: 12 });
                    const solver = new ConstraintSolver();
                    const eq = new EquivalenceEngine(false);
                    const generator = new PremiseGenerator(state, solver, eq);
                    let unique = true;
                    for (let trial = 0; trial < FIRST_N_NOVELTY; trial++) {
                        const result = generator.generate({
                            trialIndex: trial,
                            k: 2,
                            n: 2,
                            plannedMatch: false,
                            nBackPremise: null,
                            middleAtoms: [],
                            avoidLetters: null,
                            allowOverride: false
                        });
                        if (!result) {
                            unique = false;
                            break;
                        }
                        const key = result.premise.toKey();
                        if (firstPremises.has(key)) {
                            unique = false;
                        }
                        firstPremises.add(key);
                        state.novelty.register(state.novelty.buildSignatures(result.premise));
                    }
                }
                return {
                    test: 'Novelty',
                    passed: firstPremises.size >= seeds.length * FIRST_N_NOVELTY,
                    details: 'First six premises differ across restarts'
                };
            }

            async testContradictions() {
                const state = new GameState(12345, { windowSize: 12 });
                const solver = new ConstraintSolver();
                const atoms = [new Atom('N', 'A', 'B'), new Atom('S', 'A', 'B')];
                const sat = solver.evaluate([], atoms);
                return {
                    test: 'Constraint contradictions',
                    passed: !sat.ok,
                    details: 'Opposite relations rejected by SAT core'
                };
            }

            async testCertificate() {
                const premiseA = new Premise([new Atom('N', 'A', 'B'), new Atom('W', 'A', 'C')]);
                const premiseB = new Premise([new Atom('S', 'B', 'A'), new Atom('E', 'C', 'A')]);
                const eq = new EquivalenceEngine(false);
                const certificate = eq.computeCertificate(premiseA, premiseB, []);
                return {
                    test: 'Certificate generation',
                    passed: certificate.match && certificate.certificate.mapping.length === 2,
                    details: 'Invertible mapping generated for 2-atom pair'
                };
            }

            async testInputGating() {
                const engine = new GameEngine();
                await engine.voice.initialize();
                engine.totalTrials = 0;
                engine.correctResponses = 0;
                engine.totalResponses = 0;
                engine.omissions = 3;
                engine.awaitingResponse = false;
                const before = engine.score;
                engine.handleResponse(true);
                return {
                    test: 'Input gating',
                    passed: engine.score === before,
                    details: 'No score change without active response window'
                };
            }

            async testProofExamples() {
                const eq = new EquivalenceEngine(false);
                const p1 = new Premise([new Atom('N', 'A', 'B')]);
                const mid = [new Atom('N', 'B', 'C')];
                const p2 = new Premise([new Atom('N', 'A', 'C')]);
                const cert = eq.computeCertificate(p1, p2, mid);
                return {
                    test: 'Proof-based equivalence',
                    passed: !cert.match,
                    details: 'Mid-window derivable relation rejected when transitivity off'
                };
            }
        }

        const engine = new GameEngine();
        engine.initialize();
    </script>
</body>
</html>
