<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>IMAGI-WORLD: Neural Topology</title>
  <style>
    :root {
      --gold: linear-gradient(to right, #bf953f 0%, #fcf6ba 20%, #b38728 40%, #fbf5b7 60%, #aa771c 80%, #bf953f 100%);
      --bg: #020205;
      --panel: #0a0e14;
    }

```
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: #eee;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 15px;
  overflow-x: hidden;
  touch-action: manipulation;
}

h1 {
  margin: 20px 0;
  font-size: clamp(1.8rem, 10vw, 3rem);
  text-align: center;
  letter-spacing: 5px;
  font-weight: 900;
  background: var(--gold);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8));
  text-transform: uppercase;
  animation: shimmer 6s infinite linear;
  background-size: 200% auto;
}

@keyframes shimmer {
  to { background-position: 200% center; }
}

.container {
  max-width: 600px;
  width: 100%;
}

.controls {
  background: var(--panel);
  padding: 25px;
  border-radius: 20px;
  margin-bottom: 20px;
  border: 1px solid #222;
  box-shadow: 0 15px 35px rgba(0,0,0,0.8);
}

.control-group {
  margin-bottom: 18px;
}

label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
  color: #ffd700;
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 1.5px;
}

input[type="range"] {
  width: 100%;
  height: 8px;
  background: #151921;
  border-radius: 4px;
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 26px;
  height: 26px;
  background: #ffd700;
  border-radius: 50%;
  box-shadow: 0 0 15px #ffd700;
  border: 2px solid #000;
  cursor: pointer;
}

select {
  width: 100%;
  padding: 14px;
  background: #000;
  color: #fff;
  border: 1px solid #444;
  border-radius: 12px;
  font-size: 0.9rem;
  font-weight: 600;
  outline: none;
}

.button-group {
  display: flex;
  gap: 12px;
  margin-top: 15px;
}

button {
  padding: 18px;
  border-radius: 14px;
  border: none;
  font-weight: 900;
  cursor: pointer;
  transition: 0.2s;
  text-transform: uppercase;
  touch-action: manipulation;
}

#start-btn {
  flex: 2;
  background: linear-gradient(135deg, #ffd700, #b38728);
  color: #000;
}

#stop-btn {
  flex: 1;
  background: #121212;
  color: #e94560;
  border: 1px solid #401010;
}

button:disabled {
  opacity: 0.15;
  pointer-events: none;
}

.game-area {
  background: #050508;
  padding: 30px;
  border-radius: 30px;
  text-align: center;
  border: 1px solid #111;
  min-height: 480px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  box-shadow: inset 0 0 50px rgba(0,0,0,0.9);
  position: relative;
}

.status {
  font-size: 0.65rem;
  color: #444;
  letter-spacing: 5px;
  font-weight: 900;
  text-transform: uppercase;
}

#countdown-overlay {
  font-size: 6rem;
  color: #ffd700;
  font-weight: 900;
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: none;
  text-shadow: 0 0 40px #ffd700;
  z-index: 20;
}

.premise-display {
  font-size: clamp(1.1rem, 4.5vw, 1.6rem);
  color: #fff;
  margin: 20px 0;
  font-style: italic;
  min-height: 140px;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1.6;
  text-shadow: 0 0 20px rgba(255,255,255,0.05);
  padding: 15px;
}

.response-buttons {
  display: flex;
  flex-direction: column;
  gap: 15px;
  width: 100%;
}

@media (min-width: 500px) {
  .response-buttons { flex-direction: row; }
}

.response-buttons button {
  flex: 1;
  padding: 30px 20px;
  font-size: 1.5rem;
  border: 2px solid transparent;
  border-radius: 20px;
}

#match-btn {
  background: rgba(46, 204, 113, 0.05);
  color: #2ecc71;
  border-color: rgba(46, 204, 113, 0.2);
}

#no-match-btn {
  background: rgba(231, 76, 60, 0.05);
  color: #e74c3c;
  border-color: rgba(231, 76, 60, 0.2);
}

#match-btn:not(:disabled):active {
  background: #2ecc71;
  color: #000;
}

#no-match-btn:not(:disabled):active {
  background: #e74c3c;
  color: #fff;
}

.stats {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin-top: 30px;
}

.stat-box {
  background: #0a0a0f;
  padding: 15px;
  border-radius: 15px;
  border: 1px solid #111;
}

.stat-label {
  font-size: 0.55rem;
  color: #444;
  text-transform: uppercase;
  margin-bottom: 5px;
  font-weight: 800;
}

.stat-value {
  font-size: 1.2rem;
  font-weight: 900;
  color: #bf953f;
}

#feedback {
  font-size: 1.4rem;
  font-weight: 900;
  min-height: 32px;
  letter-spacing: 2px;
}

.correct {
  color: #ffd700;
  text-shadow: 0 0 15px #ffd700;
}

.incorrect {
  color: #ff4444;
}
```

  </style>
</head>
<body>
  <main class="container">
    <h1>IMAGI-WORLD</h1>

```
<div class="controls">
  <div class="control-group">
    <label>N-Back Lag: <span id="n-val" style="color:#ffd700">1</span></label>
    <input type="range" id="n-slider" min="1" max="5" value="1">
  </div>

  <div class="control-group">
    <label>Topology Geometry:</label>
    <select id="logic-mode">
      <option value="0">Mode 0: Standard Linear</option>
      <option value="1">Mode 1: Dialectical Superposition</option>
      <option value="2">Mode 2: Semantic Tensor</option>
      <option value="3">Mode 3: System Homology</option>
      <option value="4">Mode 4: Complementary Interface</option>
    </select>
  </div>

  <div class="control-group">
    <label>Thinking Time (After Speech): <span id="spt-val" style="color:#ffd700">8.0</span>s</label>
    <input type="range" id="spt-slider" min="3" max="45" step="0.5" value="8">
  </div>

  <div class="button-group">
    <button id="start-btn">Initialize Session</button>
    <button id="stop-btn" disabled>Sever</button>
  </div>
</div>

<div class="game-area">
  <div id="status" class="status">SYSTEM STANDBY</div>
  <div id="countdown-overlay"></div>
  <div id="feedback"></div>
  <div id="premise-display" class="premise-display">INITIALIZE TO BEGIN</div>

  <div class="response-buttons">
    <button id="match-btn" disabled>MATCH</button>
    <button id="no-match-btn" disabled>NO MATCH</button>
  </div>

  <div class="stats">
    <div class="stat-box">
      <div class="stat-label">Cycle</div>
      <div id="trial-count" class="stat-value">0</div>
    </div>
    <div class="stat-box">
      <div class="stat-label">Score</div>
      <div id="score" class="stat-value">0</div>
    </div>
    <div class="stat-box">
      <div class="stat-label">Prec</div>
      <div id="accuracy" class="stat-value">0%</div>
    </div>
  </div>
</div>
```

  </main>

<script type="module">
/**
 * IMAGI-WORLD TOPOLOGY ENGINE v7.2
 * 
 * FIXES:
 * - Countdown speaks "3" first (primer tone wakes Bluetooth before countdown)
 * - Countdown timing: 3 → (1s) → 2 → (1s) → 1 → (1s pause) → first premise
 * - "NO MATCH" button (removed underscore)
 * - Status messages cleaned (removed underscores)
 * - Separate speakCountdown function (no cancel interference)
 * - Running state checks throughout countdown
 * - Bluetooth primer before each premise preserved
 */

const SYMBOLS = "BCDEFGHJKLMNOPQRSTUVWXYZ".split("");
const REL = { N: 'north', S: 'south', E: 'east', W: 'west' };

class Mulberry32 {
  constructor(seed) {
    this.state = seed >>> 0;
  }

  next() {
    let t = this.state += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }

  choice(arr) {
    return arr[Math.floor(this.next() * arr.length)];
  }
}

class DaVinciEngine {
  constructor() {
    this.history = [];
    this.score = 0;
    this.total = 0;
    this.running = false;
    this.rng = new Mulberry32(Date.now());
    this.synth = window.speechSynthesis;
    this.answered = true;
    this.audioCtx = null;
    this.timer = null;
    this.currentCycleObj = null;
    this.correctIsMatch = false;
  }

  init() {
    document.getElementById('start-btn').onclick = () => this.start();
    document.getElementById('stop-btn').onclick = () => this.stop();
    document.getElementById('n-slider').oninput = (e) => {
      document.getElementById('n-val').textContent = e.target.value;
    };
    document.getElementById('spt-slider').oninput = (e) => {
      document.getElementById('spt-val').textContent = parseFloat(e.target.value).toFixed(1);
    };
    document.getElementById('match-btn').onclick = () => this.respond(true);
    document.getElementById('no-match-btn').onclick = () => this.respond(false);

    window.addEventListener('keydown', (e) => {
      if (!this.running || this.answered) return;
      if (e.code === 'Space') {
        e.preventDefault();
        this.respond(true);
      }
      if (e.code === 'Enter') {
        e.preventDefault();
        this.respond(false);
      }
    });
  }

  /**
   * Initialize Web Audio API context.
   */
  initAudioContext() {
    if (!this.audioCtx) {
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (this.audioCtx.state === 'suspended') {
      this.audioCtx.resume();
    }
  }

  /**
   * Audible primer tone to wake Bluetooth A2DP codec.
   */
  playPrimer() {
    return new Promise((resolve) => {
      if (!this.audioCtx) {
        resolve();
        return;
      }

      const oscillator = this.audioCtx.createOscillator();
      const gainNode = this.audioCtx.createGain();

      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(110, this.audioCtx.currentTime);

      gainNode.gain.setValueAtTime(0.08, this.audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 0.12);

      oscillator.connect(gainNode);
      gainNode.connect(this.audioCtx.destination);

      oscillator.start(this.audioCtx.currentTime);
      oscillator.stop(this.audioCtx.currentTime + 0.12);

      setTimeout(resolve, 120);
    });
  }

  /**
   * Speech for countdown - no cancel() to avoid queue disruption.
   */
  speakCountdown(text) {
    return new Promise((resolve) => {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 0.9;
      utterance.pitch = 1.0;

      let resolved = false;
      const finish = () => {
        if (!resolved) {
          resolved = true;
          resolve();
        }
      };

      utterance.onend = finish;
      utterance.onerror = finish;
      setTimeout(finish, 2000);

      this.synth.speak(utterance);
    });
  }

  /**
   * Speech for premises - clears queue first.
   */
  speak(text) {
    return new Promise((resolve) => {
      this.synth.cancel();

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 0.85;
      utterance.pitch = 1.0;

      let resolved = false;
      const finish = () => {
        if (!resolved) {
          resolved = true;
          resolve();
        }
      };

      utterance.onend = finish;
      utterance.onerror = finish;
      setTimeout(finish, 20000);

      this.synth.speak(utterance);
    });
  }

  /**
   * Countdown: 3 → (1s) → 2 → (1s) → 1 → (1s) → begin
   * Runs ONLY ONCE at session start.
   */
  async runInitialCountdown() {
    const overlay = document.getElementById('countdown-overlay');
    overlay.style.display = 'block';

    this.initAudioContext();

    // Wake Bluetooth BEFORE "3"
    await this.playPrimer();
    await new Promise(r => setTimeout(r, 80));

    // 3
    if (!this.running) { overlay.style.display = 'none'; return; }
    overlay.textContent = '3';
    await this.speakCountdown('3');
    await new Promise(r => setTimeout(r, 600));

    // 2
    if (!this.running) { overlay.style.display = 'none'; return; }
    overlay.textContent = '2';
    await this.speakCountdown('2');
    await new Promise(r => setTimeout(r, 600));

    // 1
    if (!this.running) { overlay.style.display = 'none'; return; }
    overlay.textContent = '1';
    await this.speakCountdown('1');
    await new Promise(r => setTimeout(r, 600));

    // 1 second pause after "1"
    if (!this.running) { overlay.style.display = 'none'; return; }
    await new Promise(r => setTimeout(r, 1000));

    overlay.style.display = 'none';
  }

  getOrtho(d1) {
    const vert = ['N', 'S'];
    const horiz = ['E', 'W'];
    return vert.includes(d1) ? this.rng.choice(horiz) : this.rng.choice(vert);
  }

  generate(mode, forceMatchKey = null) {
    const rS = () => this.rng.choice(SYMBOLS);
    const rD = () => this.rng.choice(['N', 'S', 'E', 'W']);

    let text, key;

    if (forceMatchKey) {
      key = forceMatchKey;
    } else {
      const d1 = rD(), d2 = this.getOrtho(d1);
      const bridge = rD(), d3 = rD(), d4 = rD(), d5 = rD();

      switch (parseInt(mode)) {
        case 1:
          key = `M1-${[d1, d2].sort().join('')}`;
          break;
        case 2:
          key = `M2-${[d1, d2].sort().join('')}`;
          break;
        case 3:
          key = `M3-${d1}-${bridge}`;
          break;
        case 4:
          key = `M4-${d1}${d2}-${d3}${d4}-${d5}`;
          break;
        default:
          key = `M0-${d1}`;
      }
    }

    const p = key.split('-');
    const m = p[0];

    let s1 = rS(), s2 = rS(), s3 = rS();
    while (s2 === s1) s2 = rS();
    while (s3 === s1 || s3 === s2) s3 = rS();

    if (m === 'M1') {
      const ax = p[1].split('');
      text = `${s1} is ${REL[ax[0]]} and ${REL[ax[1]]} of ${s2}`;
    } else if (m === 'M2') {
      const ax = p[1].split('');
      text = `${s1} is ${REL[ax[0]]} of ${s2} and ${REL[ax[1]]} of ${s3}`;
    } else if (m === 'M3') {
      text = `(${REL[p[1]]} of ${s1}) is ${REL[p[2]]} of (${REL[p[1]]} of ${s2})`;
    } else if (m === 'M4') {
      const pA = p[1], pB = p[2], br = p[3];
      text = `(${REL[pA[0]]}-${REL[pA[1]]} of ${s1}) is ${REL[br]} of (${REL[pB[0]]}-${REL[pB[1]]} of ${s2})`;
    } else {
      text = `${s1} is ${REL[p[1]]} of ${s2}`;
    }

    return { text, key };
  }

  async start() {
    this.running = true;
    this.score = 0;
    this.total = 0;
    this.history = [];

    document.getElementById('start-btn').disabled = true;
    document.getElementById('stop-btn').disabled = false;
    document.getElementById('status').textContent = "CALIBRATING AUDIO";

    await this.runInitialCountdown();

    if (this.running) {
      this.pulse();
    }
  }

  stop() {
    this.running = false;
    clearTimeout(this.timer);
    this.synth.cancel();

    if (this.audioCtx && this.audioCtx.state !== 'closed') {
      this.audioCtx.close().catch(() => {});
      this.audioCtx = null;
    }

    document.getElementById('start-btn').disabled = false;
    document.getElementById('stop-btn').disabled = true;
    document.getElementById('match-btn').disabled = true;
    document.getElementById('no-match-btn').disabled = true;
    document.getElementById('status').textContent = "LINK SEVERED";
    document.getElementById('countdown-overlay').style.display = 'none';
  }

  async pulse() {
    if (!this.running) return;

    const mode = document.getElementById('logic-mode').value;
    const n = parseInt(document.getElementById('n-slider').value);

    const isMatchPossible = this.history.length >= n && this.rng.next() < 0.38;
    const nBackObj = isMatchPossible ? this.history[this.history.length - n] : null;

    let current;
    let safety = 0;
    do {
      current = this.generate(mode, nBackObj ? nBackObj.key : null);
      safety++;
    } while (
      this.history.length > 0 &&
      current.text === this.history[this.history.length - 1].text &&
      safety < 10
    );

    this.correctIsMatch = (nBackObj !== null && current.key === nBackObj.key);
    this.currentCycleObj = current;
    this.answered = true;

    document.getElementById('match-btn').disabled = true;
    document.getElementById('no-match-btn').disabled = true;
    document.getElementById('feedback').textContent = "";
    document.getElementById('premise-display').textContent = current.text;
    document.getElementById('status').textContent = "PRIMING AUDIO";

    await this.playPrimer();
    if (!this.running) return;

    document.getElementById('status').textContent = "DELIVERING PROMPT";
    await this.speak(current.text);
    if (!this.running) return;

    this.answered = false;
    document.getElementById('match-btn').disabled = false;
    document.getElementById('no-match-btn').disabled = false;
    document.getElementById('status').textContent = `CYCLE ${this.total + 1} PROCESSING`;

    const thinkingTime = parseFloat(document.getElementById('spt-slider').value) * 1000;
    this.timer = setTimeout(() => {
      if (!this.answered) {
        this.respond(null);
      }
    }, thinkingTime);
  }

  respond(val) {
    if (this.answered || !this.running) return;

    this.answered = true;
    clearTimeout(this.timer);

    document.getElementById('match-btn').disabled = true;
    document.getElementById('no-match-btn').disabled = true;

    const fb = document.getElementById('feedback');

    if (val === null) {
      fb.textContent = "TIMEOUT";
      fb.className = "incorrect";
    } else if (val === this.correctIsMatch) {
      this.score++;
      fb.textContent = "SYNC SUCCESS";
      fb.className = "correct";
    } else {
      fb.textContent = "SYNC ERROR";
      fb.className = "incorrect";
    }

    this.total++;
    this.updateUI();
    this.history.push(this.currentCycleObj);

    setTimeout(() => {
      fb.textContent = "";
      if (this.running) {
        this.pulse();
      }
    }, 1000);
  }

  updateUI() {
    document.getElementById('trial-count').textContent = this.total;
    document.getElementById('score').textContent = this.score;
    document.getElementById('accuracy').textContent =
      this.total > 0 ? Math.round((this.score / this.total) * 100) + "%" : "0%";
  }
}

const engine = new DaVinciEngine();
engine.init();
</script>

</body>
</html>
